/**
 * ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è UWAGA - WERSJA PRODUKCYJNA ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
 * 
 * üö´ NIE EDYTUJ TEGO PLIKU BEZPO≈öREDNIO!
 * 
 * üìù Aby wprowadziƒá zmiany:
 * 1. Otw√≥rz KOPIƒò ROBOCZƒÑ: https://script.google.com/https://docs.google.com/spreadsheets/d/12HgcCifzhbhf_V6dunBbcrxSsWezBKo6NUizDQT9q8Q/edit?gid=0#gid=0/edit
 * 2. Wprowad≈∫ zmiany tam
 * 3. Przetestuj dok≈Çadnie
 * 4. Skopiuj tutaj tylko po testach
 * 
 * Ostatnia aktualizacja: 2025-10-23
 * Wersja: 2.0
 */

// ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è KOD PRODUKCYJNY PONI≈ªEJ ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
/**
 * SYSTEM REJESTRACJI CZASU PRACY I URLOP√ìW
 * Wersja: 2.0 - Poprawki systemu urlopowego
 * Data: 2025-01-21
 */

// ===== KONFIGURACJA =====

const SPREADSHEET_ID = '1yc46B74O84wcn1Qxi3R2Ve8vCM7aSENmGEQQ5jflv10';

/**
 * Lista polskich ≈õwiƒÖt pa≈Ñstwowych
 */
function isPolishHoliday(date) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1; // 1-12
  const day = date.getDate();
  
  // Sta≈Çe ≈õwiƒôta
  const fixedHolidays = [
    '01-01', // Nowy Rok
    '01-06', // Trzech Kr√≥li
    '05-01', // ≈öwiƒôto Pracy
    '05-03', // Konstytucja 3 Maja
    '08-15', // Wniebowziƒôcie NMP
    '11-01', // Wszystkich ≈öwiƒôtych
    '11-11', // Niepodleg≈Ço≈õƒá
    '12-25', // Bo≈ºe Narodzenie
    '12-26'  // Drugi dzie≈Ñ Bo≈ºego Narodzenia
  ];
  
  const dateStr = `${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
  
  if (fixedHolidays.includes(dateStr)) {
    return true;
  }
  
  // Wielkanoc - zmienne ≈õwiƒôta (uproszczona lista dla 2024-2026)
  const easterDates = {
    2024: ['03-31', '04-01'], // Wielkanoc + Poniedzia≈Çek Wielkanocny
    2025: ['04-20', '04-21'],
    2026: ['04-05', '04-06']
  };
  
  if (easterDates[year] && easterDates[year].includes(dateStr)) {
    return true;
  }
  
  // Bo≈ºe Cia≈Ço - 60 dni po Wielkanocy (uproszczona lista)
  const corpusChristiDates = {
    2024: '05-30',
    2025: '06-19',
    2026: '06-04'
  };
  
  if (corpusChristiDates[year] === dateStr) {
    return true;
  }
  
  return false;
}

function sprawdzUprawnienia() {
  const SPRAWDZANIE_WYLACZONE = true;
  
  if (SPRAWDZANIE_WYLACZONE) {
    return true;
  }
  
  const m√≥jEmail = Session.getActiveUser().getEmail();
  const dozwoloneEmails = [
    'logtrade24@gmail.com',
    'jerzyd@dbklogistics.com',
    'krzysztof@dbklogistics.com'
  ];
  
  if (!dozwoloneEmails.includes(m√≥jEmail)) {
    throw new Error('Brak uprawnie≈Ñ dla: ' + m√≥jEmail);
  }
}

const SHEETS = {
  LOGS: 'Logi_czasowe',
  USERS: 'Pracownicy', 
  DEPARTMENTS: 'Dzia≈Çy',
  SUMMARY: 'Podsumowanie',
  L4: 'Zwolnienia_lekarskie',
  TICKETS: 'Zg≈Çoszenia'
};

const VACATION_SHEETS = {
  REQUESTS: 'Wnioski_urlopowe'
};

const REPORT_SHEETS = {
  CACHE: 'Podsumowania_cache',
  MONTHLY: 'Raporty_miesiƒôczne'
};

const SUMMARY_SHEETS = {
  WORKER_REPORTS: 'Raporty_pracownik√≥w'
};

// ===== FUNKCJA MENU =====

function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('‚è±Ô∏è Rejestrator Czasu')
    .addItem('üìä Od≈õwie≈º raport za bie≈ºƒÖcy miesiƒÖc', 'refreshCurrentMonthReport')
    .addSeparator()
    .addItem('üîÑ Przelicz ostatni tydzie≈Ñ (cache)', 'recalculateLastWeek')
    .addItem('üîÑ Przelicz ostatni miesiƒÖc (cache)', 'recalculateLastMonth')
    .addSeparator()
    .addItem('üß™ Test obliczenia dnia', 'testCalculateSingleDay')
    .addToUi();
}

// ===== INICJALIZACJA SYSTEMU =====

function getAppUrl() {
  return ScriptApp.getService().getUrl();
}

function initializeSystem() {
  sprawdzUprawnienia();
  console.log('=== INICJALIZACJA SYSTEMU ===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  let userSheet = ss.getSheetByName(SHEETS.USERS);
  if (!userSheet) {
    console.log('Tworzƒô arkusz Pracownicy...');
    userSheet = ss.insertSheet(SHEETS.USERS);
    setupUsersSheet(userSheet);
  }
  
  const vacationResult = initializeVacationSystem();
  console.log('Inicjalizacja urlop√≥w:', vacationResult);
  
  debugVacationColumns();
  
  return {
    success: true,
    message: 'System zainicjalizowany pomy≈õlnie'
  };
}

// ===== FUNKCJE ARKUSZY =====

function createSheet(spreadsheet, sheetName, setupFunction) {
  sprawdzUprawnienia();
  let sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    sheet = spreadsheet.insertSheet(sheetName);
    setupFunction(sheet);
  }
}

function setupUsersSheet(sheet) {
  sprawdzUprawnienia();
  const headers = ['Login', 'Kod EAN', 'Imiƒô Nazwisko', 'Dzia≈Ç', 'Status', 'Urlop_przys≈ÇugujƒÖcy', 'Urlop_zaleg≈Çy', 'Urlop_wykorzystany', 'Urlop_pozosta≈Çy', 'Godz_start', 'Godz_koniec'];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sheet.getRange(1, 1, 1, headers.length).setBackground('#34a853');
  sheet.getRange(1, 1, 1, headers.length).setFontColor('white');
  
  const columnWidths = [120, 150, 180, 200, 120, 120, 120, 120, 120, 100, 100];
  columnWidths.forEach((width, index) => {
    sheet.setColumnWidth(index + 1, width);
  });
  
  sheet.setFrozenRows(1);
}

// ===== FUNKCJE POBIERANIA DANYCH =====

function getUsersFromSpreadsheet() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  const departments = {};
  
  for (let i = 1; i < data.length; i++) {
    const [login, code, name, deptName, status] = data[i];
    
    if (!login) continue;
    
    const deptId = getDepartmentId(deptName);
    
    if (!departments[deptId]) {
      departments[deptId] = {
        name: deptName,
        users: []
      };
    }
    
    departments[deptId].users.push({
      login: login,
      code: code.toString(),
      name: name,
      status: status,
      currentDepartment: deptName
    });
  }
  
  return departments;
}

function getDepartmentsList() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const deptSheet = ss.getSheetByName(SHEETS.DEPARTMENTS);
  
  const data = deptSheet.getDataRange().getValues();
  const headers = data[0];
  
  const idCol = headers.indexOf('ID');
  const nameCol = headers.indexOf('Nazwa');
  const statusCol = headers.indexOf('Status');
  
  const activeDepartments = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const id = row[idCol];
    const name = row[nameCol];
    const status = row[statusCol];
    
    if (id && name && status === 'Aktywny') {
      activeDepartments.push({
        id: id,
        name: name
      });
    }
  }
  
  return activeDepartments;
}

function getDepartmentsData() {
  sprawdzUprawnienia();
  return getUsersFromSpreadsheet();
}

function getDepartmentId(deptName) {
  const mapping = {
    'Przyjƒôcie dostaw': 'przyjecie',
    'Roz≈Çadunek rƒôczny kontenera': 'rozladunek',
    'Za≈Çadunek rƒôczny kontenera': 'zaladunek',
    'Relokacja': 'relokacja',
    'Kompletacja zam√≥wie≈Ñ': 'kompletacja',
    'Weryfikacja zam√≥wie≈Ñ': 'weryfikacja',
    'Co-packing': 'co-packing',
    'Operacje porzƒÖdkowe': 'operacje-porzadkowe',
    'Inwentaryzacja': 'inwentaryzacja'
  };
  
  return mapping[deptName] || 'inne';
}

function getDepartmentName(deptId) {
  const mapping = {
    'przyjecie': 'Przyjƒôcie dostaw',
    'rozladunek': 'Roz≈Çadunek rƒôczny kontenera',
    'zaladunek': 'Za≈Çadunek rƒôczny kontenera',
    'relokacja': 'Relokacja',
    'kompletacja': 'Kompletacja zam√≥wie≈Ñ',
    'weryfikacja': 'Weryfikacja zam√≥wie≈Ñ',
    'co-packing': 'Co-packing',
    'operacje-porzadkowe': 'Operacje porzƒÖdkowe',
    'inwentaryzacja': 'Inwentaryzacja'
  };
  return mapping[deptId] || deptId;
}

/**
 * Pobiera wszystkich pracownik√≥w z arkusza Pracownicy
 */
function getAllEmployees() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const pracownicySheet = ss.getSheetByName('Pracownicy');
    
    if (!pracownicySheet) {
      Logger.log('B≈ÅƒÑD: Nie znaleziono arkusza Pracownicy');
      return [];
    }
    
    const data = pracownicySheet.getDataRange().getValues();
    const headers = data[0];
    
    // Znajd≈∫ indeksy kolumn
    const loginIndex = headers.indexOf('login');
    const imieNazwiskoIndex = headers.indexOf('imie_nazwisko');
    
    Logger.log('Login index: ' + loginIndex + ', Imiƒô_nazwisko index: ' + imieNazwiskoIndex);
    
    if (loginIndex === -1 || imieNazwiskoIndex === -1) {
      Logger.log('B≈ÅƒÑD: Nie znaleziono wymaganych kolumn');
      return [];
    }
    
    const employees = [];
    
    // Pomi≈Ñ nag≈Ç√≥wek (wiersz 0)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Pomi≈Ñ puste wiersze
      if (!row[loginIndex]) continue;
      
      const fullName = row[imieNazwiskoIndex] || '';
      const nameParts = fullName.split(' ');
      
      employees.push({
        login: row[loginIndex],
        firstName: nameParts[0] || '',
        lastName: nameParts.slice(1).join(' ') || ''
      });
    }
    
    Logger.log('Za≈Çadowano ' + employees.length + ' pracownik√≥w');
    return employees;
    
  } catch (error) {
    Logger.log('B≈ÅƒÑD getAllEmployees: ' + error.toString());
    return [];
  }
}

// ===== WERYFIKACJA KODU =====

function verifyUserCode(login, inputCode) {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  const cleanInputCode = inputCode.toString()
    .replace(/^~+/g, '')
    .replace(/~+$/g, '')
    .replace(/\s/g, '')
    .replace(/\n/g, '')
    .replace(/\r/g, '')
    .trim();
  
  console.log('=== WERYFIKACJA KODU ===');
  console.log('Login:', login);
  console.log('Kod oryginalny:', `"${inputCode}"`);
  console.log('Kod po oczyszczeniu:', `"${cleanInputCode}"`);
  
  for (let i = 1; i < data.length; i++) {
    const [userLogin, userCode, userName, deptName, status] = data[i];
    
    if (userLogin === login) {
      const cleanUserCode = userCode.toString()
        .replace(/^~+/g, '')
        .replace(/~+$/g, '')
        .replace(/\s/g, '')
        .trim();
      
      console.log('Kod z bazy:', `"${userCode}"`);
      console.log('Kod z bazy po oczyszczeniu:', `"${cleanUserCode}"`);
      
      const isCodeCorrect = cleanInputCode === cleanUserCode;
      
      return {
        success: isCodeCorrect,
        user: {
          login: userLogin,
          code: userCode,
          name: userName,
          department: deptName,
          status: status
        },
        message: isCodeCorrect ? 'Kod poprawny' : 'Nieprawid≈Çowy kod EAN'
      };
    }
  }
  
  return {
    success: false,
    user: null,
    message: 'Nie znaleziono u≈ºytkownika'
  };
}

// ===== FUNKCJE LOGOWANIA CZASU =====

function getCurrentUserOperation(login) {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  const data = logsSheet.getDataRange().getValues();
  
  for (let i = data.length - 1; i >= 1; i--) {
    const [id, timestamp, userLogin, name, department, code, operationType, status] = data[i];
    
    if (userLogin === login) {
      const actionCode = getActionCodeFromText(operationType);
      if (actionCode === 'wchodzi' || actionCode === 'zmieniam-operacje') {
        return department;
      }
    }
  }
  
  const userData = findUserData(login);
  return userData ? userData.department : null;
}

function getActionCodeFromText(operationText) {
  const textToCode = {
    'Wchodzƒô do pracy': 'wchodzi',
    'Wychodzƒô na przerwƒô': 'wychodzi-przerwa',
    'Wracam z przerwy': 'wracam',
    'Wychodzƒô z pracy': 'wychodzi-pracy',
    'Zmieniam operacjƒô': 'zmieniam-operacje'
  };
  return textToCode[operationText] || operationText;
}

function addTimeEntry(login, department, action, timestamp = null) {
  sprawdzUprawnienia();
  
  let dateObj;
  if (!timestamp) {
    dateObj = new Date();
  } else if (typeof timestamp === 'string') {
    dateObj = new Date(timestamp);
  } else if (timestamp instanceof Date) {
    dateObj = timestamp;
  } else {
    dateObj = new Date();
  }
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  
  const userData = findUserData(login);
  if (!userData) {
    throw new Error(`Nie znaleziono pracownika: ${login}`);
  }
  
  let finalDepartment = department;
  if (action === 'wychodzi-przerwa' || action === 'wracam') {
    const currentOperation = getCurrentUserOperation(login);
    if (currentOperation) {
      finalDepartment = currentOperation;
    }
  }
  
  const row = logsSheet.getLastRow() + 1;
  const id = row - 1;
  const formattedTimestamp = Utilities.formatDate(dateObj, 'Europe/Warsaw', 'yyyy-MM-dd HH:mm:ss');
  const timeOnly = Utilities.formatDate(dateObj, 'Europe/Warsaw', 'HH:mm:ss');
  const dateOnly = Utilities.formatDate(dateObj, 'Europe/Warsaw', 'yyyy-MM-dd');
  
  const actionText = getActionText(action);
  const status = getStatusFromAction(action);
  
  const logData = [
    id, formattedTimestamp, login, userData.name, finalDepartment,
    userData.code, actionText, status, timeOnly, dateOnly
  ];
  
  logsSheet.getRange(row, 1, 1, logData.length).setValues([logData]);
  updateUserStatus(login, status);
  
  return {
    success: true,
    message: `Zapisano: ${actionText}`,
    timestamp: formattedTimestamp,
    user: userData.name
  };
}

function findUserData(login) {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === login) {
      return {
        login: data[i][0],
        code: data[i][1],
        name: data[i][2],
        department: data[i][3],
        status: data[i][4]
      };
    }
  }
  return null;
}

function updateUserStatus(login, newStatus) {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === login) {
      sheet.getRange(i + 1, 5).setValue(newStatus);
      break;
    }
  }
}

function getActionText(action) {
  const actions = {
    'wchodzi': 'Wchodzƒô do pracy',
    'wychodzi-przerwa': 'Wychodzƒô na przerwƒô',
    'wychodzi-pracy': 'Wychodzƒô z pracy',
    'wracam': 'Wracam z przerwy',
    'zmieniam-operacje': 'Zmieniam operacjƒô'
  };
  return actions[action] || action;
}

function getStatusFromAction(action) {
  const statusMap = {
    'wchodzi': 'Pracuje',
    'wychodzi-przerwa': 'Na przerwie', 
    'wychodzi-pracy': 'Nieaktywny',
    'wracam': 'Pracuje',
    'zmieniam-operacje': 'Pracuje'
  };
  return statusMap[action] || 'Nieznany';
}

// ===== SYSTEM URLOP√ìW - INICJALIZACJA =====

function setupVacationRequestsSheet(sheet) {
  sprawdzUprawnienia();
  const headers = [
    'ID', 'Login', 'Imiƒô_Nazwisko', 'Data_zlozenia', 'Data_od', 'Data_do', 
    'Dni_robocze', 'Status', 'Typ_urlopu', 'Komentarz_pracownika', 
    'Data_decyzji', 'Komentarz_kierownika'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sheet.getRange(1, 1, 1, headers.length).setBackground('#9c27b0');
  sheet.getRange(1, 1, 1, headers.length).setFontColor('white');
  
  const columnWidths = [50, 120, 180, 120, 100, 100, 80, 120, 100, 200, 120, 200];
  columnWidths.forEach((width, index) => {
    sheet.setColumnWidth(index + 1, width);
  });
  
  sheet.setFrozenRows(1);
}

function createVacationSheetsIfNeeded() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  createSheet(ss, VACATION_SHEETS.REQUESTS, setupVacationRequestsSheet);
}

function initializeVacationSystem() {
  sprawdzUprawnienia();
  createVacationSheetsIfNeeded();
  addMissingVacationColumns();
  return true;
}

function addMissingVacationColumns() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  
  if (!sheet) {
    throw new Error('Arkusz Pracownicy nie istnieje!');
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const requiredColumns = ['Urlop_przys≈ÇugujƒÖcy', 'Urlop_zaleg≈Çy', 'Urlop_wykorzystany', 'Urlop_pozosta≈Çy'];
  
  let columnsToAdd = [];
  
  for (const column of requiredColumns) {
    if (!headers.includes(column)) {
      columnsToAdd.push(column);
    }
  }
  
  if (columnsToAdd.length > 0) {
    const startCol = headers.length + 1;
    
    for (let i = 0; i < columnsToAdd.length; i++) {
      sheet.getRange(1, startCol + i).setValue(columnsToAdd[i]);
      sheet.getRange(1, startCol + i).setFontWeight('bold');
      sheet.getRange(1, startCol + i).setBackground('#34a853');
      sheet.getRange(1, startCol + i).setFontColor('white');
      sheet.setColumnWidth(startCol + i, 120);
    }
    
    const dataRange = sheet.getDataRange();
    const numRows = dataRange.getNumRows();
    
    if (numRows > 1) {
      for (let row = 2; row <= numRows; row++) {
        const login = sheet.getRange(row, 1).getValue();
        if (login) {
          let colIndex = startCol;
          for (const column of columnsToAdd) {
            let defaultValue = 0;
            if (column === 'Urlop_przys≈ÇugujƒÖcy') defaultValue = 20;
            if (column === 'Urlop_pozosta≈Çy') defaultValue = 20;
            
            sheet.getRange(row, colIndex).setValue(defaultValue);
            colIndex++;
          }
        }
      }
    }
    
    console.log(`Dodano kolumny: ${columnsToAdd.join(', ')}`);
    return `Dodano ${columnsToAdd.length} kolumn urlopowych`;
  }
  
  return 'Wszystkie kolumny ju≈º istniejƒÖ';
}

// ===== SYSTEM URLOP√ìW - FUNKCJE POMOCNICZE (POPRAWIONE) =====

function getSafeNumericValue(row, columnIndex, defaultValue) {
  if (columnIndex === -1) {
    console.log(`Kolumna nie istnieje, zwracam domy≈õlnƒÖ warto≈õƒá: ${defaultValue}`);
    return defaultValue;
  }
  
  const rawValue = row[columnIndex];
  
  if (rawValue === null || rawValue === undefined) {
    console.log(`Warto≈õƒá null/undefined, zwracam domy≈õlnƒÖ: ${defaultValue}`);
    return defaultValue;
  }
  
  if (rawValue === '') {
    console.log(`Pusty string, zwracam domy≈õlnƒÖ: ${defaultValue}`);
    return defaultValue;
  }
  
  const numericValue = parseFloat(rawValue);
  
  if (isNaN(numericValue)) {
    console.log(`Nie jest liczbƒÖ, zwracam domy≈õlnƒÖ: ${defaultValue}`);
    return defaultValue;
  }
  
  console.log(`Zwracam warto≈õƒá: ${numericValue}`);
  return numericValue;
}

function getDefaultBalance() {
  console.log('‚ö†Ô∏è  Zwracam domy≈õlne warto≈õci saldo (wszystkie zera)');
  return {
    przys≈ÇugujƒÖcy: 0,
    zaleg≈Çy: 0,
    wykorzystany: 0,
    pozosta≈Çy: 0
  };
}

function getUserVacationBalance(login) {
  sprawdzUprawnienia();
  console.log('=== getUserVacationBalance dla:', login, '===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  
  if (!sheet) {
    console.error('Arkusz Pracownicy nie istnieje!');
    return getDefaultBalance();
  }
  
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) {
    console.error('Brak danych w arkuszu Pracownicy');
    return getDefaultBalance();
  }
  
  const headers = data[0];
  console.log('Wszystkie nag≈Ç√≥wki:', headers);
  
  const loginIndex = headers.indexOf('login'); 
  const loginIndexUpper = headers.indexOf('Login'); 
  const finalLoginIndex = loginIndex !== -1 ? loginIndex : loginIndexUpper;
  
  if (finalLoginIndex === -1) {
    console.error('B≈ÅƒÑD: Nie znaleziono kolumny Login/login');
    return getDefaultBalance();
  }
  
  const przyslugujacyIndex = headers.indexOf('Urlop_przys≈ÇugujƒÖcy');
  const zalegleIndex = headers.indexOf('Urlop_zaleg≈Çy');
  const wykorzystanyIndex = headers.indexOf('Urlop_wykorzystany');
  const pozostalyIndex = headers.indexOf('Urlop_pozosta≈Çy');
  
  console.log('Indeksy kolumn urlopowych:');
  console.log('- Przys≈ÇugujƒÖcy:', przyslugujacyIndex);
  console.log('- Zaleg≈Çy:', zalegleIndex);
  console.log('- Wykorzystany:', wykorzystanyIndex);
  console.log('- Pozosta≈Çy:', pozostalyIndex);
  
  for (let i = 1; i < data.length; i++) {
    const userLogin = String(data[i][finalLoginIndex]).trim();
    
    if (userLogin === login) {
      console.log('ZNALEZIONO u≈ºytkownika w wierszu:', i + 1);
      const userRow = data[i];
      
      const przys≈ÇugujƒÖcy = getSafeNumericValue(userRow, przyslugujacyIndex, 0);
      const zaleg≈Çy = getSafeNumericValue(userRow, zalegleIndex, 0);
      const wykorzystany = getSafeNumericValue(userRow, wykorzystanyIndex, 0);
      const pozosta≈Çy = getSafeNumericValue(userRow, pozostalyIndex, 0);
      
      const result = {
        przys≈ÇugujƒÖcy: przys≈ÇugujƒÖcy,
        zaleg≈Çy: zaleg≈Çy,
        wykorzystany: wykorzystany,
        pozosta≈Çy: pozosta≈Çy
      };
      
      console.log('KO≈ÉCOWY WYNIK:', result);
      return result;
    }
  }
  
  console.error('Nie znaleziono u≈ºytkownika:', login);
  return getDefaultBalance();
}

// ===== SYSTEM URLOP√ìW - SK≈ÅADANIE WNIOSK√ìW (POPRAWIONE) =====

function calculateWorkingDays(startDate, endDate) {
  const holidays = [
    '2025-01-01', '2025-01-06', '2025-04-20', '2025-04-21', 
    '2025-05-01', '2025-05-03', '2025-06-08', '2025-06-19',
    '2025-08-15', '2025-11-01', '2025-11-11', '2025-12-25', '2025-12-26'
  ];
  
  let count = 0;
  let current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    const dayOfWeek = current.getDay();
    const dateStr = Utilities.formatDate(current, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    if (dayOfWeek !== 0 && dayOfWeek !== 6 && !holidays.includes(dateStr)) {
      count++;
    }
    current.setDate(current.getDate() + 1);
  }
  
  return count;
}

function submitVacationRequest(login, startDate, endDate, comment = '', vacationType = 'planowany') {
  sprawdzUprawnienia();
  createVacationSheetsIfNeeded();
  
  const start = new Date(startDate);
  const end = new Date(endDate);
  const today = new Date();
  
  if (vacationType === 'planowany') {
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (start < tomorrow) {
      return {
        success: false,
        message: 'Urlop planowany musi byƒá z≈Ço≈ºony z wyprzedzeniem min. 1 dzie≈Ñ'
      };
    }
  }
  
  const workingDays = calculateWorkingDays(start, end);
  if (workingDays > 10) {
    return {
      success: false,
      message: 'Maksymalny urlop to 10 dni roboczych'
    };
  }
  
  const balance = getUserVacationBalance(login);
  console.log('Saldo urlopowe u≈ºytkownika:', balance);
  
  if (balance.przys≈ÇugujƒÖcy === 0 && balance.pozosta≈Çy === 0) {
    return {
      success: false,
      message: 'Brak dostƒôpnych dni urlopu. Nie mo≈ºesz z≈Ço≈ºyƒá wniosku.'
    };
  }
  
  const maxDostepne = balance.przys≈ÇugujƒÖcy + balance.zaleg≈Çy;
  console.log(`Dostƒôpne dni: ${maxDostepne} (przys≈ÇugujƒÖcy: ${balance.przys≈ÇugujƒÖcy} + zaleg≈Çy: ${balance.zaleg≈Çy})`);
  console.log(`Pr√≥ba wystawienia: ${workingDays} dni`);
  
  if (workingDays > maxDostepne) {
    return {
      success: false,
      message: `Nie masz wystarczajƒÖcej liczby dni urlopu. Dostƒôpne: ${maxDostepne} dni, pr√≥bujesz wystawiƒá: ${workingDays} dni`
    };
  }
  
  const userData = findUserData(login);
  if (!userData) {
    return {
      success: false,
      message: 'Nie znaleziono pracownika'
    };
  }
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const row = sheet.getLastRow() + 1;
  const id = row - 1;
  
  const requestData = [
    id, login, userData.name,
    Utilities.formatDate(today, 'Europe/Warsaw', 'yyyy-MM-dd'),
    Utilities.formatDate(start, 'Europe/Warsaw', 'yyyy-MM-dd'),
    Utilities.formatDate(end, 'Europe/Warsaw', 'yyyy-MM-dd'),
    workingDays, 'OczekujƒÖcy', vacationType, comment, '', ''
  ];
  
  sheet.getRange(row, 1, 1, requestData.length).setValues([requestData]);
  
  return {
    success: true,
    message: `Wniosek urlopowy z≈Ço≈ºony (${workingDays} dni)`,
    requestId: id
  };
}

function getVacationRequests(login) {
  sprawdzUprawnienia();
  createVacationSheetsIfNeeded();
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = sheet.getDataRange().getValues();
  const requests = [];
  
  for (let i = 1; i < data.length; i++) {
    const [id, userLogin, name, dateSubmitted, dateFrom, dateTo, workingDays, status, vacationType, commentEmployee, dateDecision, commentManager] = data[i];
    
    if (userLogin === login) {
      requests.push({
        id: id,
        dateFrom: formatDate(dateFrom),
        dateTo: formatDate(dateTo),
        workingDays: workingDays,
        status: status,
        vacationType: vacationType || 'planowany',
        commentEmployee: commentEmployee,
        dateSubmitted: formatDate(dateSubmitted),
        dateDecision: dateDecision ? formatDate(dateDecision) : '',
        commentManager: commentManager
      });
    }
  }
  
  return requests;
}

function getPendingVacationRequests() {
  sprawdzUprawnienia();
  createVacationSheetsIfNeeded();
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = sheet.getDataRange().getValues();
  const pending = [];
  
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, dateSubmitted, dateFrom, dateTo, workingDays, status, vacationType, commentEmployee] = data[i];
    
    if (status === 'OczekujƒÖcy') {
      const collisions = checkVacationCollisions(dateFrom, dateTo, id);
      
      pending.push({
        id: id,
        login: login,
        name: name,
        dateFrom: formatDate(dateFrom),
        dateTo: formatDate(dateTo),
        workingDays: workingDays,
        vacationType: vacationType || 'planowany',
        commentEmployee: commentEmployee,
        dateSubmitted: formatDate(dateSubmitted),
        collisions: collisions
      });
    }
  }
  
  return pending;
}

function getPendingVacationCount() {
  sprawdzUprawnienia();
  const pending = getPendingVacationRequests();
  return pending.length;
}

/**
 * Pobiera ≈ÇƒÖcznƒÖ liczbƒô WSZYSTKICH oczekujƒÖcych wniosk√≥w o nieobecno≈õƒá
 * (urlopy + dni wolne + okoliczno≈õciowe + plan roczny)
 */
function getPendingAbsenceRequestsCount() {
  sprawdzUprawnienia();
  console.log('=== ZLICZANIE WSZYSTKICH OCZEKUJƒÑCYCH WNIOSK√ìW ===');
  
  let totalCount = 0;
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    
    // 1. Urlopy wypoczynkowe (istniejƒÖca logika)
    const vacationSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
    if (vacationSheet && vacationSheet.getLastRow() > 1) {
      const vacData = vacationSheet.getRange(2, 8, vacationSheet.getLastRow() - 1, 1).getValues();
      vacData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') totalCount++;
      });
    }
    
    // 2. Dni wolne
    const dayOffSheet = ss.getSheetByName('Dni_wolne');
    if (dayOffSheet && dayOffSheet.getLastRow() > 1) {
      const dayOffData = dayOffSheet.getRange(2, 10, dayOffSheet.getLastRow() - 1, 1).getValues();
      dayOffData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') totalCount++;
      });
    }
    
    // 3. Urlopy okoliczno≈õciowe
    const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    if (occasionalSheet && occasionalSheet.getLastRow() > 1) {
      const occasionalData = occasionalSheet.getRange(2, 10, occasionalSheet.getLastRow() - 1, 1).getValues();
      occasionalData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') totalCount++;
      });
    }
    
    // 4. Plan roczny
    const yearPlanSheet = ss.getSheetByName('Plan_roczny');
    if (yearPlanSheet && yearPlanSheet.getLastRow() > 1) {
      const yearPlanData = yearPlanSheet.getRange(2, 8, yearPlanSheet.getLastRow() - 1, 1).getValues();
      yearPlanData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') totalCount++;
      });
    }
    
    console.log('‚úÖ ≈ÅƒÖczna liczba oczekujƒÖcych wniosk√≥w: ' + totalCount);
    return totalCount;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getPendingAbsenceRequestsCount:', error);
    return 0;
  }
}

function checkVacationCollisions(startDate, endDate, excludeRequestId = null) {
  sprawdzUprawnienia();
  createVacationSheetsIfNeeded();
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = sheet.getDataRange().getValues();
  
  let conflictingRequests = 0;
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, dateSubmitted, dateFrom, dateTo, workingDays, status] = data[i];
    
    if (excludeRequestId && id === excludeRequestId) continue;
    if (status !== 'Zatwierdzony') continue;
    
    const existingStart = new Date(dateFrom);
    const existingEnd = new Date(dateTo);
    
    if (start <= existingEnd && end >= existingStart) {
      conflictingRequests++;
    }
  }
  
  return {
    conflicts: conflictingRequests,
    maxAllowed: 3,
    canApprove: conflictingRequests < 3
  };
}

// ===== SYSTEM URLOP√ìW - PRZETWARZANIE WNIOSK√ìW (POPRAWIONE) =====

function processVacationRequest(requestId, decision, managerComment = '') {
  sprawdzUprawnienia();
  console.log('=== ROZPOCZYNAM PRZETWARZANIE WNIOSKU ===');
  console.log('Request ID:', requestId, 'Decision:', decision, 'Comment:', managerComment);
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  
  if (!sheet) {
    console.error('Arkusz wniosk√≥w urlopowych nie istnieje!');
    return { success: false, message: 'Arkusz wniosk√≥w nie istnieje' };
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  console.log('Nag≈Ç√≥wki arkusza wniosk√≥w:', headers);
  
  let requestRowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == requestId) {
      requestRowIndex = i;
      break;
    }
  }
  
  if (requestRowIndex === -1) {
    console.error('Nie znaleziono wniosku o ID:', requestId);
    return { success: false, message: 'Nie znaleziono wniosku' };
  }
  
  console.log('Znaleziono wniosek w wierszu:', requestRowIndex + 1);
  
  const today = new Date();
  const todayString = Utilities.formatDate(today, 'Europe/Warsaw', 'yyyy-MM-dd');
  const login = data[requestRowIndex][1];
  const workingDays = data[requestRowIndex][6];
  
  console.log('Dane wniosku - Login:', login, 'Dni:', workingDays, 'Decyzja:', decision);
  
  try {
    sheet.getRange(requestRowIndex + 1, 8).setValue(decision);
    sheet.getRange(requestRowIndex + 1, 11).setValue(todayString);
    sheet.getRange(requestRowIndex + 1, 12).setValue(managerComment);
    
    console.log('Zaktualizowano status wniosku na:', decision);
    
    if (decision === 'Zatwierdzony') {
      console.log('Wniosek zatwierdzony - aktualizujƒô saldo urlopowe');
      const balanceUpdated = updateVacationBalance(login, parseInt(workingDays));
      
      if (!balanceUpdated) {
        console.error('B≈ÇƒÖd aktualizacji saldo urlopowego');
        return { 
          success: false, 
          message: 'Wniosek zatwierdzony, ale b≈ÇƒÖd aktualizacji saldo' 
        };
      }
    }
    
    SpreadsheetApp.flush();
    
    // Aktualizuj podsumowanie nieobecno≈õci
    try {
      updateAbsenceSummary();
    } catch (e) {
      console.log('Uwaga: nie uda≈Ço siƒô zaktualizowaƒá podsumowania:', e);
    }
    
    console.log('=== PRZETWARZANIE WNIOSKU ZAKO≈ÉCZONE ===');
    return {
      success: true,
      message: `Wniosek ${decision.toLowerCase()}`
    };
    
  } catch (error) {
    console.error('B≈ÇƒÖd podczas przetwarzania wniosku:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd systemu podczas przetwarzania'
    };
  }
}

function updateVacationBalance(login, daysUsed) {
  sprawdzUprawnienia();
  console.log('=== AKTUALIZACJA SALDO URLOPOWEGO ===');
  console.log('Login:', login, 'Dni do odjƒôcia:', daysUsed);
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  
  if (!sheet) {
    console.error('Arkusz Pracownicy nie istnieje!');
    return false;
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  console.log('Wszystkie nag≈Ç√≥wki:', headers);
  
  const loginIndex = headers.indexOf('login') !== -1 ? headers.indexOf('login') : headers.indexOf('Login');
  const przyslugujacyIndex = headers.indexOf('Urlop_przys≈ÇugujƒÖcy');
  const zalegleIndex = headers.indexOf('Urlop_zaleg≈Çy');
  const wykorzystanyIndex = headers.indexOf('Urlop_wykorzystany');
  const pozostalyIndex = headers.indexOf('Urlop_pozosta≈Çy');
  
  console.log('Indeksy kolumn:');
  console.log('- Login:', loginIndex);
  console.log('- Przys≈ÇugujƒÖcy:', przyslugujacyIndex);
  console.log('- Zaleg≈Çy:', zalegleIndex);
  console.log('- Wykorzystany:', wykorzystanyIndex);
  console.log('- Pozosta≈Çy:', pozostalyIndex);
  
  if (loginIndex === -1) {
    console.error('Nie znaleziono kolumny Login');
    return false;
  }
  
  if (wykorzystanyIndex === -1 || pozostalyIndex === -1) {
    console.error('Nie znaleziono kolumn urlopowych');
    return false;
  }
  
  let userRowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    const currentLogin = String(data[i][loginIndex]).trim();
    console.log(`Sprawdzam wiersz ${i + 1}: "${currentLogin}" vs "${login}"`);
    
    if (currentLogin === login) {
      userRowIndex = i;
      console.log('ZNALEZIONO u≈ºytkownika w wierszu:', i + 1);
      break;
    }
  }
  
  if (userRowIndex === -1) {
    console.error('Nie znaleziono u≈ºytkownika:', login);
    return false;
  }
  
  const currentPrzyslugujacy = getSafeNumericValue(data[userRowIndex], przyslugujacyIndex, 0);
  const currentZalegle = getSafeNumericValue(data[userRowIndex], zalegleIndex, 0);
  const currentWykorzystany = getSafeNumericValue(data[userRowIndex], wykorzystanyIndex, 0);
  const currentPozostaly = getSafeNumericValue(data[userRowIndex], pozostalyIndex, 0);
  
  console.log('Obecne warto≈õci:');
  console.log('- Przys≈ÇugujƒÖcy:', currentPrzyslugujacy);
  console.log('- Zaleg≈Çy:', currentZalegle);
  console.log('- Wykorzystany:', currentWykorzystany);
  console.log('- Pozosta≈Çy:', currentPozostaly);
  
  const newWykorzystany = currentWykorzystany + daysUsed;
  const totalDostepne = currentPrzyslugujacy + currentZalegle;
  const newPozostaly = Math.max(0, totalDostepne - newWykorzystany);
  
  console.log('Nowe warto≈õci:');
  console.log('- Nowy wykorzystany:', newWykorzystany);
  console.log('- Nowy pozosta≈Çy:', newPozostaly);
  console.log('- Obliczenia: Total dostƒôpne:', totalDostepne, '- Wykorzystany:', newWykorzystany, '= Pozosta≈Çy:', newPozostaly);
  
  try {
    const usedCell = sheet.getRange(userRowIndex + 1, wykorzystanyIndex + 1);
    console.log('Aktualizujƒô kom√≥rkƒô wykorzystany:', usedCell.getA1Notation());
    usedCell.setValue(newWykorzystany);
    
    const remainingCell = sheet.getRange(userRowIndex + 1, pozostalyIndex + 1);
    console.log('Aktualizujƒô kom√≥rkƒô pozosta≈Çy:', remainingCell.getA1Notation());
    remainingCell.setValue(newPozostaly);
    
    SpreadsheetApp.flush();
    
    console.log('=== AKTUALIZACJA ZAKO≈ÉCZONA POMY≈öLNIE ===');
    return true;
    
  } catch (error) {
    console.error('B≈ÇƒÖd podczas aktualizacji:', error);
    return false;
  }
}

// ===== FUNKCJE DIAGNOSTYCZNE =====

function debugVacationColumns() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  
  if (!sheet) {
    console.error('Arkusz Pracownicy nie istnieje!');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  console.log('=== DIAGNOSTYKA KOLUMN ARKUSZA PRACOWNICY ===');
  console.log('Liczba kolumn:', headers.length);
  console.log('Wszystkie nag≈Ç√≥wki:', headers);
  
  headers.forEach((header, index) => {
    console.log(`Kolumna ${index + 1} (${String.fromCharCode(65 + index)}): "${header}"`);
  });
  
  console.log('Indeks Login:', headers.indexOf('Login'));
  console.log('Indeks Urlop_przys≈ÇugujƒÖcy:', headers.indexOf('Urlop_przys≈ÇugujƒÖcy'));
  console.log('Indeks Urlop_zaleg≈Çy:', headers.indexOf('Urlop_zaleg≈Çy'));
  console.log('Indeks Urlop_wykorzystany:', headers.indexOf('Urlop_wykorzystany'));
  console.log('Indeks Urlop_pozosta≈Çy:', headers.indexOf('Urlop_pozosta≈Çy'));
  
  const data = sheet.getDataRange().getValues();
  if (data.length > 1) {
    console.log('=== PRZYK≈ÅADOWE DANE U≈ªYTKOWNIKA ===');
    console.log('Wiersz 2:', data[1]);
  }
}

function testVacationSystemAfterFixes() {
  console.log('=== TEST SYSTEMU URLOP√ìW PO POPRAWKACH ===');
  
  const balance = getUserVacationBalance('jerzyd');
  console.log('\n1. Saldo u≈ºytkownika jerzyd:', balance);
  
  console.log('\n2. Test walidacji wniosku:');
  
  const testBalance = {
    przys≈ÇugujƒÖcy: 0,
    zaleg≈Çy: 0,
    pozosta≈Çy: 0,
    wykorzystany: 20
  };
  
  console.log('Saldo testowe:', testBalance);
  
  if (testBalance.przys≈ÇugujƒÖcy === 0 && testBalance.pozosta≈Çy === 0) {
    console.log('‚úÖ WALIDACJA OK: U≈ºytkownik z zerowymi warto≈õciami nie mo≈ºe z≈Ço≈ºyƒá wniosku');
  } else {
    console.log('‚ùå B≈ÅƒÑD: U≈ºytkownik z zerowymi warto≈õciami m√≥g≈Çby z≈Ço≈ºyƒá wniosek!');
  }
  
  if (testBalance.przys≈ÇugujƒÖcy === 0) {
    console.log('‚úÖ POPRAWKA DZIA≈ÅA: Warto≈õƒá 0 jest zachowana (nie zamieniona na 26)');
  } else {
    console.log('‚ùå B≈ÅƒÑD: Warto≈õƒá 0 zosta≈Ça zamieniona na:', testBalance.przys≈ÇugujƒÖcy);
  }
  
  console.log('\n=== KONIEC TESTU ===');
}

// ===== FUNKCJE POMOCNICZE =====

function formatDate(date) {
  if (!date) return '';
  if (date instanceof Date) {
    return Utilities.formatDate(date, 'Europe/Warsaw', 'yyyy-MM-dd');
  }
  return date.toString();
}

function isManager(login) {
  return login === 'jerzyd';
}

// ===== SYSTEM RAPORTOWANIA =====

function setupReportCacheSheet(sheet) {
  sprawdzUprawnienia();
  
  const headers = [
    'ID', 'Login', 'Imiƒô_Nazwisko', 'Data', 
    'Godziny_nale≈ºne', 'Godziny_przepracowane', 'Bilans_godzin',
    'Czas_przerw_min', 'Liczba_przerw', 'Najd≈Çu≈ºsza_przerwa_min',
    'Godzina_wej≈õcia', 'Godzina_wyj≈õcia', 
    'Sp√≥≈∫nienie', 'Wczesne_wyj≈õcie',
    'Przyjƒôcie_min', 'Roz≈Çadunek_min', 'Za≈Çadunek_min',
    'Relokacja_min', 'Kompletacja_min', 'Weryfikacja_min',
    'Co_packing_min', 'Operacje_porzƒÖdkowe_min', 'Inwentaryzacja_min',
    'Liczba_zmian_operacji', 'Stosunek_przerw_procent',
    'Status_dnia', 'Data_obliczenia'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sheet.getRange(1, 1, 1, headers.length).setBackground('#673ab7');
  sheet.getRange(1, 1, 1, headers.length).setFontColor('white');
  sheet.setFrozenRows(1);
  
  sheet.setColumnWidth(1, 50);
  sheet.setColumnWidth(2, 120);
  sheet.setColumnWidth(3, 180);
  sheet.setColumnWidth(4, 100);
}

function createReportSheetsIfNeeded() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  let cacheSheet = ss.getSheetByName(REPORT_SHEETS.CACHE);
  if (!cacheSheet) {
    cacheSheet = ss.insertSheet(REPORT_SHEETS.CACHE);
    setupReportCacheSheet(cacheSheet);
    console.log('Utworzono arkusz:', REPORT_SHEETS.CACHE);
  }
  
  return true;
}

function getWorkerPlannedHours(login) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  const loginIdx = headers.indexOf('login') !== -1 ? headers.indexOf('login') : headers.indexOf('Login');
  const startIdx = headers.indexOf('Godz_start');
  const endIdx = headers.indexOf('Godz_koniec');
  
  const defaultHours = {
    start: '08:00',
    end: '16:00'
  };
  
  if (loginIdx === -1) {
    console.log(`‚ö†Ô∏è Nie znaleziono kolumny Login`);
    return defaultHours;
  }
  
  if (startIdx === -1 || endIdx === -1) {
    console.log(`‚ö†Ô∏è Nie znaleziono kolumn Godz_start lub Godz_koniec, u≈ºywam domy≈õlnych: 08:00-16:00`);
    return defaultHours;
  }
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][loginIdx] === login) {
      const startTime = data[i][startIdx];
      const endTime = data[i][endIdx];
      
      if (!startTime || !endTime) {
        console.log(`‚ö†Ô∏è Brak godzin dla ${login}, u≈ºywam domy≈õlnych: 08:00-16:00`);
        return defaultHours;
      }
      
      console.log(`‚úÖ Godziny dla ${login}: ${startTime} - ${endTime}`);
      return {
        start: startTime.toString(),
        end: endTime.toString()
      };
    }
  }
  
  console.log(`‚ö†Ô∏è Nie znaleziono pracownika ${login}, u≈ºywam domy≈õlnych: 08:00-16:00`);
  return defaultHours;
}

function checkIfLate(actualEntry, plannedStart) {
  if (!actualEntry || !plannedStart) return 'NIE';
  
  const timeStr = plannedStart.toString().trim();
  const timeParts = timeStr.split(':');
  
  if (timeParts.length !== 2) {
    console.log(`‚ö†Ô∏è Nieprawid≈Çowy format godziny: ${plannedStart}`);
    return 'NIE';
  }
  
  const plannedHour = parseInt(timeParts[0]);
  const plannedMinute = parseInt(timeParts[1]);
  
  const actualHour = actualEntry.getHours();
  const actualMinute = actualEntry.getMinutes();
  
  const plannedMinutes = plannedHour * 60 + plannedMinute;
  const actualMinutes = actualHour * 60 + actualMinute;
  
  const tolerance = 5;
  
  if (actualMinutes > plannedMinutes + tolerance) {
    const lateMinutes = actualMinutes - plannedMinutes;
    console.log(`  ‚è∞ Sp√≥≈∫nienie: planowane ${plannedStart}, rzeczywiste ${String(actualHour).padStart(2, '0')}:${String(actualMinute).padStart(2, '0')} (${lateMinutes} min sp√≥≈∫nienia)`);
    return 'TAK';
  }
  
  return 'NIE';
}

function checkIfEarlyExit(actualExit, plannedEnd) {
  if (!actualExit || !plannedEnd) return 'NIE';
  
  const timeStr = plannedEnd.toString().trim();
  const timeParts = timeStr.split(':');
  
  if (timeParts.length !== 2) {
    console.log(`‚ö†Ô∏è Nieprawid≈Çowy format godziny: ${plannedEnd}`);
    return 'NIE';
  }
  
  const plannedHour = parseInt(timeParts[0]);
  const plannedMinute = parseInt(timeParts[1]);
  
  const actualHour = actualExit.getHours();
  const actualMinute = actualExit.getMinutes();
  
  const plannedMinutes = plannedHour * 60 + plannedMinute;
  const actualMinutes = actualHour * 60 + actualMinute;
  
  const tolerance = 5;
  
  if (actualMinutes < plannedMinutes - tolerance) {
    const earlyMinutes = plannedMinutes - actualMinutes;
    console.log(`  ‚è∞ Wczesne wyj≈õcie: planowane ${plannedEnd}, rzeczywiste ${String(actualHour).padStart(2, '0')}:${String(actualMinute).padStart(2, '0')} (${earlyMinutes} min wcze≈õniej)`);
    return 'TAK';
  }
  
  return 'NIE';
}

function recalculateLastWeek() {
  sprawdzUprawnienia();
  const today = new Date();
  const weekAgo = new Date(today);
  weekAgo.setDate(weekAgo.getDate() - 7);
  
  const startDate = Utilities.formatDate(weekAgo, 'Europe/Warsaw', 'yyyy-MM-dd');
  const endDate = Utilities.formatDate(today, 'Europe/Warsaw', 'yyyy-MM-dd');
  
  return recalculateWorkReports(startDate, endDate);
}

function recalculateLastMonth() {
  sprawdzUprawnienia();
  const today = new Date();
  const monthAgo = new Date(today);
  monthAgo.setMonth(monthAgo.getMonth() - 1);
  
  const startDate = Utilities.formatDate(monthAgo, 'Europe/Warsaw', 'yyyy-MM-dd');
  const endDate = Utilities.formatDate(today, 'Europe/Warsaw', 'yyyy-MM-dd');
  
  return recalculateWorkReports(startDate, endDate);
}

function refreshCurrentMonthReport() {
  sprawdzUprawnienia();
  console.log('=== OD≈öWIE≈ªANIE RAPORTU ZA BIE≈ªƒÑCY MIESIƒÑC ===');
  
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
  
  const startDate = Utilities.formatDate(firstDay, 'Europe/Warsaw', 'yyyy-MM-dd');
  const endDate = Utilities.formatDate(yesterday, 'Europe/Warsaw', 'yyyy-MM-dd');
  
  console.log('MiesiƒÖc:', today.getMonth() + 1, '/', today.getFullYear());
  console.log('Okres: OD', startDate, 'DO', endDate, '(do wczoraj w≈ÇƒÖcznie)');
  
  console.log('Krok 1: Przeliczam cache...');
  const cacheResult = recalculateWorkReports(startDate, endDate);
  console.log('Cache przeliczony:', cacheResult.recordsProcessed, 'rekord√≥w');
  
  console.log('Krok 2: Generujƒô raport zbiorczy...');
  const reportResult = generateWorkerSummary(startDate, endDate);
  console.log('Raport wygenerowany:', reportResult.workersProcessed, 'pracownik√≥w');
  
  return {
    success: true,
    message: `Raport za ${today.getMonth() + 1}/${today.getFullYear()} od≈õwie≈ºony pomy≈õlnie`,
    cacheRecords: cacheResult.recordsProcessed,
    workers: reportResult.workersProcessed,
    period: `${startDate} - ${endDate}`
  };
}

function recalculateWorkReports(startDate, endDate) {
  sprawdzUprawnienia();
  console.log('=== ROZPOCZYNAM PRZELICZANIE RAPORT√ìW ===');
  console.log('Okres:', startDate, '-', endDate);
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  createReportSheetsIfNeeded();
  
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  const cacheSheet = ss.getSheetByName(REPORT_SHEETS.CACHE);
  
  if (!logsSheet) {
    throw new Error('Arkusz Logi_czasowe nie istnieje!');
  }
  
  const logsData = logsSheet.getDataRange().getValues();
  const headers = logsData[0];
  
  const loginIdx = headers.indexOf('login');
  const timestampIdx = headers.indexOf('czas');
  const nameIdx = headers.indexOf('imie_nazwisko');
  const departmentIdx = headers.indexOf('dzia≈Ç');
  const actionIdx = headers.indexOf('operacja');
  const statusIdx = headers.indexOf('status');
  const dateIdx = headers.indexOf('data');
  
  const userDailyData = {};
  
  for (let i = 1; i < logsData.length; i++) {
    const row = logsData[i];
    const login = row[loginIdx];
    const dateStr = row[dateIdx];
    
    if (!login || !dateStr) continue;
    
    if (startDate && dateStr < startDate) continue;
    if (endDate && dateStr > endDate) continue;
    
    const key = `${login}_${dateStr}`;
    
    if (!userDailyData[key]) {
      userDailyData[key] = {
        login: login,
        name: row[nameIdx],
        date: dateStr,
        entries: []
      };
    }
    
    userDailyData[key].entries.push({
      timestamp: row[timestampIdx],
      department: row[departmentIdx],
      action: row[actionIdx],
      status: row[statusIdx]
    });
  }
  
  console.log('Znaleziono rekord√≥w do przetworzenia:', Object.keys(userDailyData).length);
  
  const cacheData = [];
  let rowId = 1;
  
  for (const key in userDailyData) {
    const dayData = userDailyData[key];
    const calculated = calculateDayMetrics(dayData);
    
    cacheData.push([
      rowId++,
      calculated.login,
      calculated.name,
      calculated.date,
      calculated.godzinyNale≈ºne,
      calculated.godzinyPrzepracowane,
      calculated.bilansGodzin,
      calculated.czasPrzerwMin,
      calculated.liczbaPrzerw,
      calculated.najd≈Çu≈ºszaPrzerwaMin,
      calculated.godzinaWej≈õcia,
      calculated.godzinaWyj≈õcia,
      calculated.sp√≥≈∫nienie,
      calculated.wczesneWyj≈õcie,
      calculated.przyjƒôcieMin || 0,
      calculated.roz≈ÇadunekMin || 0,
      calculated.za≈ÇadunekMin || 0,
      calculated.relokacjaMin || 0,
      calculated.kompletacjaMin || 0,
      calculated.weryfikacjaMin || 0,
      calculated.coPackingMin || 0,
      calculated.operacjePorzƒÖdkoweMin || 0,
      calculated.inwentaryzacjaMin || 0,
      calculated.liczbaZmianOperacji,
      calculated.stosunekPrzerwProcent,
      calculated.statusDnia,
      new Date()
    ]);
  }
  
  if (cacheData.length > 0) {
    console.log('=== AKTUALIZACJA CACHE ===');
    console.log('Okres do zaktualizowania:', startDate, '-', endDate);
    
    const allData = cacheSheet.getDataRange().getValues();
    const headers = allData[0];
    const dateColIdx = headers.indexOf('Data');
    
    if (dateColIdx === -1) {
      console.error('Nie znaleziono kolumny Data!');
      return { success: false, message: 'B≈ÇƒÖd struktury arkusza' };
    }
    
    const rowsToKeep = [];
    let removedCount = 0;
    
    for (let i = 1; i < allData.length; i++) {
      const row = allData[i];
      const rowDateRaw = row[dateColIdx];
      const rowDate = formatDateString(rowDateRaw);
      
      if (rowDate < startDate || rowDate > endDate) {
        rowsToKeep.push(row);
      } else {
        removedCount++;
      }
    }
    
    console.log('Usuniƒôto starych wpis√≥w:', removedCount);
    console.log('Zachowano wpis√≥w spoza okresu:', rowsToKeep.length);
    console.log('Dodajƒô nowych wpis√≥w:', cacheData.length);
    
    if (cacheSheet.getLastRow() > 1) {
      cacheSheet.deleteRows(2, cacheSheet.getLastRow() - 1);
    }
    
    const allNewData = rowsToKeep.concat(cacheData);
    
    if (allNewData.length > 0) {
      cacheSheet.getRange(2, 1, allNewData.length, allNewData[0].length)
        .setValues(allNewData);
    }
    
    console.log('RAZEM wpis√≥w w cache:', allNewData.length);
    console.log('=== KONIEC AKTUALIZACJI CACHE ===');
  }
  
  return {
    success: true,
    recordsProcessed: cacheData.length,
    period: `${startDate} - ${endDate}`
  };
}

function calculateDayMetrics(dayData) {
  const entries = dayData.entries.sort((a, b) => 
    new Date(a.timestamp) - new Date(b.timestamp)
  );
console.log(`=== Obliczam metryki dla ${dayData.login} w dniu ${dayData.date} ===`);
  console.log(`Liczba wpis√≥w: ${entries.length}`);
  
  let totalWorkMin = 0;
  let totalBreakMin = 0;
  let breakCount = 0;
  let longestBreakMin = 0;
  let operationChanges = 0;
  let firstEntry = null;
  let lastExit = null;
  
  const operationTime = {};
  let currentSession = null;
  let breakStart = null;
  
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const timestamp = new Date(entry.timestamp);
    const action = (entry.action || '').toString();
    const department = (entry.department || '').toString();
    
    console.log(`  ${i + 1}. ${timestamp.toLocaleTimeString('pl-PL')} | ${action} | ${department}`);
    
    if (!firstEntry) {
      firstEntry = timestamp;
    }
    
    const actionNormalized = action.toLowerCase().trim();
    
    if (actionNormalized.includes('wchodz') && actionNormalized.includes('prac')) {
      console.log('    ‚Üí Rozpoczyna pracƒô');
      currentSession = {
        start: timestamp,
        department: department
      };
    }
    
    else if (actionNormalized.includes('wracam') && actionNormalized.includes('przerw')) {
      if (breakStart) {
        const breakDuration = (timestamp - breakStart) / 60000;
        totalBreakMin += breakDuration;
        breakCount++;
        longestBreakMin = Math.max(longestBreakMin, breakDuration);
        console.log(`    ‚Üí Zako≈Ñczono przerwƒô (${Math.round(breakDuration)} min)`);
        breakStart = null;
      }
      
      currentSession = {
        start: timestamp,
        department: department
      };
    }
    
    else if (actionNormalized.includes('wychodz') && actionNormalized.includes('przerw')) {
      if (currentSession) {
        const workDuration = (timestamp - currentSession.start) / 60000;
        totalWorkMin += workDuration;
        
        if (!operationTime[currentSession.department]) {
          operationTime[currentSession.department] = 0;
        }
        operationTime[currentSession.department] += workDuration;
        
        console.log(`    ‚Üí Zako≈Ñczono pracƒô (${Math.round(workDuration)} min w ${currentSession.department})`);
        currentSession = null;
      }
      
      breakStart = timestamp;
      console.log('    ‚Üí Rozpoczyna przerwƒô');
    }
    
    else if (actionNormalized.includes('wychodz') && actionNormalized.includes('prac')) {
      if (currentSession) {
        const workDuration = (timestamp - currentSession.start) / 60000;
        totalWorkMin += workDuration;
        
        if (!operationTime[currentSession.department]) {
          operationTime[currentSession.department] = 0;
        }
        operationTime[currentSession.department] += workDuration;
        
        console.log(`    ‚Üí Zako≈Ñczono pracƒô (${Math.round(workDuration)} min w ${currentSession.department})`);
        currentSession = null;
      }
      
      lastExit = timestamp;
      console.log('    ‚Üí Wychodzi z pracy');
    }
    
    else if (actionNormalized.includes('zmieniam') || actionNormalized.includes('zmieni')) {
      if (currentSession) {
        const workDuration = (timestamp - currentSession.start) / 60000;
        totalWorkMin += workDuration;
        
        if (!operationTime[currentSession.department]) {
          operationTime[currentSession.department] = 0;
        }
        operationTime[currentSession.department] += workDuration;
        
        console.log(`    ‚Üí Zako≈Ñczono pracƒô (${Math.round(workDuration)} min w ${currentSession.department})`);
        operationChanges++;
      }
      
      currentSession = {
        start: timestamp,
        department: department
      };
      console.log(`    ‚Üí Zmiana operacji na: ${department}`);
    }
  }
  
  if (currentSession) {
    const sessionDate = new Date(currentSession.start);
    const endOfDay = new Date(sessionDate);
    endOfDay.setHours(23, 59, 59, 999);
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const sessionDay = new Date(sessionDate);
    sessionDay.setHours(0, 0, 0, 0);
    
    const endTime = sessionDay.getTime() === today.getTime() ? new Date() : endOfDay;
    const workDuration = (endTime - currentSession.start) / 60000;
    totalWorkMin += workDuration;
    
    if (!operationTime[currentSession.department]) {
      operationTime[currentSession.department] = 0;
    }
    operationTime[currentSession.department] += workDuration;
    
    console.log(`  ‚ö†Ô∏è Sesja nie zamkniƒôta - doliczam czas do ${Utilities.formatDate(endTime, 'Europe/Warsaw', 'HH:mm')} (${Math.round(workDuration)} min)`);
  }
  
  console.log(`  SUMA: ${Math.round(totalWorkMin)} min pracy, ${Math.round(totalBreakMin)} min przerw`);
  
  const godzinyNale≈ºne = 8.0;
  
  let czasObecnosciMin = totalWorkMin + totalBreakMin;
  if (firstEntry && lastExit) {
    czasObecnosciMin = (lastExit - firstEntry) / 60000;
    console.log(`  ‚è∞ Czas obecno≈õci: ${firstEntry.toLocaleTimeString('pl-PL')} - ${lastExit.toLocaleTimeString('pl-PL')} = ${Math.round(czasObecnosciMin)} min`);
  }
  
  const godzinyObecnosci = Math.round(czasObecnosciMin / 60 * 100) / 100;
  const bilansGodzinObecnosci = Math.round((godzinyObecnosci - godzinyNale≈ºne) * 100) / 100;
  
  const stosunekPrzerwProcent = totalWorkMin > 0 ? 
    Math.round(totalBreakMin / totalWorkMin * 10000) / 100 : 0;
  
  let statusDnia = '‚úÖ OK';
  if (stosunekPrzerwProcent > 6) statusDnia = 'üî¥ PRZEKROCZENIE PRZERW';
  else if (stosunekPrzerwProcent > 4.2) statusDnia = 'üü° PRZERWY POWY≈ªEJ NORMY';
  if (bilansGodzinObecnosci < -1) statusDnia = 'üî¥ NIEDOB√ìR GODZIN';
  
  const plannedHours = getWorkerPlannedHours(dayData.login);
  const sp√≥≈∫nienie = checkIfLate(firstEntry, plannedHours.start);
  const wczesneWyj≈õcie = checkIfEarlyExit(lastExit, plannedHours.end);
  
  console.log(`  OBECNO≈öƒÜ: ${godzinyObecnosci}h (${Math.round(czasObecnosciMin)} min)`);
  console.log(`  BILANS: ${bilansGodzinObecnosci}h`);
  
  const result = {
    login: dayData.login,
    name: dayData.name,
    date: dayData.date,
    godzinyNale≈ºne: godzinyNale≈ºne,
    godzinyPrzepracowane: godzinyObecnosci,
    bilansGodzin: bilansGodzinObecnosci,
    czasPrzerwMin: Math.round(totalBreakMin),
    liczbaPrzerw: breakCount,
    najd≈Çu≈ºszaPrzerwaMin: Math.round(longestBreakMin),
    godzinaWej≈õcia: firstEntry ? Utilities.formatDate(firstEntry, 'Europe/Warsaw', 'HH:mm') : '-',
    godzinaWyj≈õcia: lastExit ? Utilities.formatDate(lastExit, 'Europe/Warsaw', 'HH:mm') : '-',
    sp√≥≈∫nienie: sp√≥≈∫nienie,
    wczesneWyj≈õcie: wczesneWyj≈õcie,
    liczbaZmianOperacji: operationChanges,
    stosunekPrzerwProcent: stosunekPrzerwProcent,
    statusDnia: statusDnia
  };
  
  for (const dept in operationTime) {
    const deptLower = dept.toLowerCase().trim();
    let mappedName = null;
    
    if (deptLower.includes('przyj')) mappedName = 'przyjƒôcieMin';
    else if (deptLower.includes('roz≈Çad') || deptLower.includes('rozlad')) mappedName = 'roz≈ÇadunekMin';
    else if (deptLower.includes('za≈Çad') || deptLower.includes('zalad')) mappedName = 'za≈ÇadunekMin';
    else if (deptLower.includes('relok')) mappedName = 'relokacjaMin';
    else if (deptLower.includes('komplet')) mappedName = 'kompletacjaMin';
    else if (deptLower.includes('weryf')) mappedName = 'weryfikacjaMin';
    else if (deptLower.includes('co-pack') || deptLower.includes('copacking')) mappedName = 'coPackingMin';
    else if (deptLower.includes('porz') || deptLower.includes('porzad')) mappedName = 'operacjePorzƒÖdkoweMin';
    else if (deptLower.includes('inwent')) mappedName = 'inwentaryzacjaMin';
    
    if (mappedName) {
      result[mappedName] = Math.round(operationTime[dept]);
      console.log(`  Operacja: ${dept} ‚Üí ${mappedName} = ${Math.round(operationTime[dept])} min`);
    }
  }
  
  return result;
}

function testCalculateSingleDay() {
  sprawdzUprawnienia();
  
  const testLogin = 'jerzyd';
  const testDate = '2025-11-09';
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  const logsData = logsSheet.getDataRange().getValues();
  const headers = logsData[0];

  console.log('=== DEBUGOWANIE NAG≈Å√ìWK√ìW ===');
  console.log('Wszystkie nag≈Ç√≥wki:', headers);
  
  const loginIdx = headers.indexOf('login');
  const timestampIdx = headers.indexOf('czas');
  const nameIdx = headers.indexOf('imie_nazwisko');
  const departmentIdx = headers.indexOf('dzia≈Ç');
  const actionIdx = headers.indexOf('operacja');
  const dateIdx = headers.indexOf('data');
  
  const entries = [];
  for (let i = 1; i < logsData.length; i++) {
    const row = logsData[i];
    const login = row[loginIdx];
    const dateValue = row[dateIdx];
    
    let dateStr = '';
    if (dateValue instanceof Date) {
      dateStr = Utilities.formatDate(dateValue, 'Europe/Warsaw', 'yyyy-MM-dd');
    } else {
      dateStr = dateValue.toString();
    }
    
    if (login === testLogin && dateStr === testDate) {
      entries.push({
        timestamp: row[timestampIdx],
        department: row[departmentIdx],
        action: row[actionIdx],
        status: row[headers.indexOf('status')]
      });
    }
  }
  
  console.log('=== ZNALEZIONE WPISY DLA', testLogin, testDate, '===');
  console.log('Liczba wpis√≥w:', entries.length);
  
  if (entries.length === 0) {
    console.log('‚ùå BRAK WPIS√ìW - sprawd≈∫ format daty i loginu!');
    return null;
  }
  
  const dayData = {
    login: testLogin,
    name: 'Jerzy Dwurznik',
    date: testDate,
    entries: entries
  };
  
  const result = calculateDayMetrics(dayData);
  
  console.log('=== WYNIK OBLICZE≈É ===');
  console.log('Godziny przepracowane:', result.godzinyPrzepracowane);
  console.log('Czas przerw (min):', result.czasPrzerwMin);
  console.log('Bilans:', result.bilansGodzin);
  
  return result;
}

function setupWorkerReportsSheet(sheet) {
  sprawdzUprawnienia();
  
  const headers = [
    'Login', 'Imiƒô_Nazwisko', 'Okres_od', 'Okres_do',
    'Dni_obecno≈õci', 'Godziny_nale≈ºne', 'Godziny_przepracowane', 'Bilans_godzin',
    'Przerwy_≈ÇƒÖcznie_min', 'Przerwy_≈õrednio_min', 'Stosunek_przerw_%',
    'Liczba_sp√≥≈∫nie≈Ñ', 'Liczba_wczesnych_wyj≈õƒá',
    'Przyjƒôcie_h', 'Roz≈Çadunek_h', 'Za≈Çadunek_h', 'Relokacja_h',
    'Kompletacja_h', 'Weryfikacja_h', 'Co_packing_h',
    'Operacje_porzƒÖdkowe_h', 'Inwentaryzacja_h',
    'Status', 'Data_wygenerowania'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  sheet.getRange(1, 1, 1, headers.length).setBackground('#ff6f00');
  sheet.getRange(1, 1, 1, headers.length).setFontColor('white');
  sheet.setFrozenRows(1);
  
  sheet.setColumnWidth(1, 120);
  sheet.setColumnWidth(2, 180);
  sheet.setColumnWidth(3, 100);
  sheet.setColumnWidth(4, 100);
  
  console.log('Utworzono arkusz:', SUMMARY_SHEETS.WORKER_REPORTS);
}

function createWorkerReportSheetIfNeeded() {
  sprawdzUprawnienia();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  let sheet = ss.getSheetByName(SUMMARY_SHEETS.WORKER_REPORTS);
  if (!sheet) {
    sheet = ss.insertSheet(SUMMARY_SHEETS.WORKER_REPORTS);
    setupWorkerReportsSheet(sheet);
    console.log('Utworzono nowy arkusz raport√≥w');
  }
  
  return sheet;
}

function generateWorkerSummary(startDate, endDate) {
  sprawdzUprawnienia();
  console.log('=== GENEROWANIE RAPORTU PRACOWNIK√ìW ===');
  console.log('Okres:', startDate, '-', endDate);
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  const cacheSheet = ss.getSheetByName(REPORT_SHEETS.CACHE);
  if (!cacheSheet) {
    throw new Error('Arkusz Podsumowania_cache nie istnieje! Uruchom najpierw recalculateWorkReports()');
  }
  
  const reportSheet = createWorkerReportSheetIfNeeded();
  
  const cacheData = cacheSheet.getDataRange().getValues();
  const cacheHeaders = cacheData[0];
  
  console.log('Liczba wierszy w cache:', cacheData.length - 1);
  
  const idx = {
    login: cacheHeaders.indexOf('Login'),
    name: cacheHeaders.indexOf('Imiƒô_Nazwisko'),
    date: cacheHeaders.indexOf('Data'),
    godzinyPrzepracowane: cacheHeaders.indexOf('Godziny_przepracowane'),
    bilans: cacheHeaders.indexOf('Bilans_godzin'),
    czasPrzerw: cacheHeaders.indexOf('Czas_przerw_min'),
    liczbaPrzerw: cacheHeaders.indexOf('Liczba_przerw'),
    godzinaWejscia: cacheHeaders.indexOf('Godzina_wej≈õcia'),
    godzinaWyjscia: cacheHeaders.indexOf('Godzina_wyj≈õcia'),
    sp√≥≈∫nienie: cacheHeaders.indexOf('Sp√≥≈∫nienie'),
    wczesneWyj≈õcie: cacheHeaders.indexOf('Wczesne_wyj≈õcie'),
    przyjƒôcie: cacheHeaders.indexOf('Przyjƒôcie_min'),
    roz≈Çadunek: cacheHeaders.indexOf('Roz≈Çadunek_min'),
    za≈Çadunek: cacheHeaders.indexOf('Za≈Çadunek_min'),
    relokacja: cacheHeaders.indexOf('Relokacja_min'),
    kompletacja: cacheHeaders.indexOf('Kompletacja_min'),
    weryfikacja: cacheHeaders.indexOf('Weryfikacja_min'),
    coPacking: cacheHeaders.indexOf('Co_packing_min'),
    operacjePorzƒÖdkowe: cacheHeaders.indexOf('Operacje_porzƒÖdkowe_min'),
    inwentaryzacja: cacheHeaders.indexOf('Inwentaryzacja_min'),
    stosunekPrzerw: cacheHeaders.indexOf('Stosunek_przerw_procent')
  };
  
  const workerData = {};
  
  for (let i = 1; i < cacheData.length; i++) {
    const row = cacheData[i];
    const login = row[idx.login];
    const dateStr = formatDateString(row[idx.date]);
    
    if (!login || !dateStr) continue;
    
    if (dateStr < startDate || dateStr > endDate) continue;
    
    if (!workerData[login]) {
      workerData[login] = {
        login: login,
        name: row[idx.name],
        days: 0,
        totalHours: 0,
        totalBreakMin: 0,
        breakCount: 0,
        lateCount: 0,
        earlyExitCount: 0,
        operations: {
          przyjƒôcie: 0,
          roz≈Çadunek: 0,
          za≈Çadunek: 0,
          relokacja: 0,
          kompletacja: 0,
          weryfikacja: 0,
          coPacking: 0,
          operacjePorzƒÖdkowe: 0,
          inwentaryzacja: 0
        },
        breakPercentages: []
      };
    }
    
    const worker = workerData[login];
    
    const godzinaWejscia = row[idx.godzinaWejscia];
    const bylWPracy = godzinaWejscia && godzinaWejscia !== '-';
    
    if (bylWPracy) {
      worker.days++;
      console.log(`  ${login} - ${dateStr}: By≈Ç w pracy (wej≈õcie: ${godzinaWejscia}) ‚Üí dzie≈Ñ nale≈ºny`);
    } else {
      console.log(`  ${login} - ${dateStr}: Brak wej≈õcia - NIE liczƒô jako dzie≈Ñ nale≈ºny`);
    }
    
    worker.totalHours += parseFloat(row[idx.godzinyPrzepracowane]) || 0;
    worker.totalBreakMin += parseFloat(row[idx.czasPrzerw]) || 0;
    
    if (row[idx.sp√≥≈∫nienie] === 'TAK') worker.lateCount++;
    if (row[idx.wczesneWyj≈õcie] === 'TAK') worker.earlyExitCount++;
    
    worker.operations.przyjƒôcie += parseFloat(row[idx.przyjƒôcie]) || 0;
    worker.operations.roz≈Çadunek += parseFloat(row[idx.roz≈Çadunek]) || 0;
    worker.operations.za≈Çadunek += parseFloat(row[idx.za≈Çadunek]) || 0;
    worker.operations.relokacja += parseFloat(row[idx.relokacja]) || 0;
    worker.operations.kompletacja += parseFloat(row[idx.kompletacja]) || 0;
    worker.operations.weryfikacja += parseFloat(row[idx.weryfikacja]) || 0;
    worker.operations.coPacking += parseFloat(row[idx.coPacking]) || 0;
    worker.operations.operacjePorzƒÖdkowe += parseFloat(row[idx.operacjePorzƒÖdkowe]) || 0;
    worker.operations.inwentaryzacja += parseFloat(row[idx.inwentaryzacja]) || 0;
    
    const breakPct = parseFloat(row[idx.stosunekPrzerw]) || 0;
    if (breakPct > 0) {
      worker.breakPercentages.push(breakPct);
    }
  }
  
  console.log('Znaleziono pracownik√≥w:', Object.keys(workerData).length);
  
  const outputData = [];
  
  for (const login in workerData) {
    const w = workerData[login];
    
    const godzinyNale≈ºne = w.days * 8.0;
    const bilans = Math.round((w.totalHours - godzinyNale≈ºne) * 100) / 100;
    const przerwy≈örednio = w.days > 0 ? Math.round(w.totalBreakMin / w.days) : 0;
    
    const avgBreakPct = w.breakPercentages.length > 0 ?
      Math.round(w.breakPercentages.reduce((a, b) => a + b, 0) / w.breakPercentages.length * 100) / 100 : 0;
    
    let status = '‚úÖ OK';
    if (bilans < -8) status = 'üî¥ NIEDOB√ìR GODZIN';
    else if (bilans < -2) status = 'üü° UWAGA';
    else if (avgBreakPct > 6) status = 'üî¥ PRZEKROCZENIE PRZERW';
    else if (avgBreakPct > 4.2) status = 'üü° PRZERWY POWY≈ªEJ NORMY';
    
    console.log(`${login}: ${w.days} dni √ó 8h = ${godzinyNale≈ºne}h nale≈ºne, przepracowane: ${Math.round(w.totalHours * 100) / 100}h, bilans: ${bilans}h`);
    
    outputData.push([
      w.login,
      w.name,
      startDate,
      endDate,
      w.days,
      godzinyNale≈ºne,
      Math.round(w.totalHours * 100) / 100,
      bilans,
      Math.round(w.totalBreakMin),
      przerwy≈örednio,
      avgBreakPct,
      w.lateCount,
      w.earlyExitCount,
      Math.round(w.operations.przyjƒôcie / 60 * 100) / 100,
      Math.round(w.operations.roz≈Çadunek / 60 * 100) / 100,
      Math.round(w.operations.za≈Çadunek / 60 * 100) / 100,
      Math.round(w.operations.relokacja / 60 * 100) / 100,
      Math.round(w.operations.kompletacja / 60 * 100) / 100,
      Math.round(w.operations.weryfikacja / 60 * 100) / 100,
      Math.round(w.operations.coPacking / 60 * 100) / 100,
      Math.round(w.operations.operacjePorzƒÖdkowe / 60 * 100) / 100,
      Math.round(w.operations.inwentaryzacja / 60 * 100) / 100,
      status,
      new Date()
    ]);
  }
  
  console.log('Czyszczƒô arkusz raport√≥w...');
  if (reportSheet.getLastRow() > 1) {
    reportSheet.deleteRows(2, reportSheet.getLastRow() - 1);
    console.log('Wyczyszczono stare raporty');
  }
  
  if (outputData.length > 0) {
    const lastRow = reportSheet.getLastRow();
    reportSheet.getRange(lastRow + 1, 1, outputData.length, outputData[0].length).setValues(outputData);
    console.log('Zapisano raport√≥w:', outputData.length);
  }
  
  return {
    success: true,
    workersProcessed: outputData.length,
    period: `${startDate} - ${endDate}`
  };
}

function formatDateString(dateValue) {
  if (!dateValue) return '';
  if (dateValue instanceof Date) {
    return Utilities.formatDate(dateValue, 'Europe/Warsaw', 'yyyy-MM-dd');
  }
  return dateValue.toString();
}

function generateVacationRequestPDF(requestId) {
  sprawdzUprawnienia();
  console.log('=== GENEROWANIE PDF DLA WNIOSKU:', requestId, '===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  
  if (!sheet) {
    throw new Error('Arkusz wniosk√≥w nie istnieje');
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  let requestRow = null;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == requestId) {
      requestRow = data[i];
      break;
    }
  }
  
  if (!requestRow) {
    throw new Error('Nie znaleziono wniosku o ID: ' + requestId);
  }
  
  const request = {
    id: requestRow[0],
    login: requestRow[1],
    name: requestRow[2],
    dateSubmitted: formatDate(requestRow[3]),
    dateFrom: formatDate(requestRow[4]),
    dateTo: formatDate(requestRow[5]),
    workingDays: requestRow[6],
    status: requestRow[7],
    vacationType: requestRow[8] || 'planowany',
    commentEmployee: requestRow[9] || '',
    dateDecision: requestRow[10] ? formatDate(requestRow[10]) : '',
    commentManager: requestRow[11] || ''
  };
  
  const balance = getUserVacationBalance(request.login);
  
  const html = generateVacationRequestHTML(request, balance);
  
  const blob = Utilities.newBlob(html, 'text/html', 'wniosek.html');
  const pdf = blob.getAs('application/pdf');
  const fileName = `Wniosek_urlopowy_${request.name.replace(/\s+/g, '_')}_${request.dateFrom}_${request.dateTo}.pdf`;
  pdf.setName(fileName);
  
  console.log('PDF wygenerowany:', fileName);
  
  return {
    success: true,
    fileName: fileName,
    pdfBlob: pdf,
    downloadUrl: createDownloadUrl(pdf)
  };
}

function generateVacationRequestHTML(request, balance) {
  const typeLabel = request.vacationType === 'na_zadanie' ? '‚òë Na ≈ºƒÖdanie  ‚òê Planowany' : '‚òê Na ≈ºƒÖdanie  ‚òë Planowany';
  const statusLabel = request.status === 'Zatwierdzony' ? '‚òë Zatwierdzam wniosek' : '‚òê Zatwierdzam wniosek';
  const statusReject = request.status === 'Odrzucony' ? '‚òë Odmawiam udzielenia urlopu' : '‚òê Odmawiam udzielenia urlopu';
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    @page {
      size: A4;
      margin: 1.5cm;
    }
    body {
      font-family: Arial, sans-serif;
      font-size: 10pt;
      line-height: 1.3;
      color: #000;
      margin: 0;
      padding: 0;
    }
    .header {
      text-align: center;
      font-size: 13pt;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 8px;
      border: 2px solid #000;
    }
    .section {
      margin-bottom: 12px;
    }
    .field {
      margin: 4px 0;
      padding-left: 10px;
      font-size: 9.5pt;
    }
    .field-label {
      font-weight: bold;
      display: inline-block;
      width: 180px;
    }
    .box {
      border: 1px solid #000;
      padding: 10px;
      margin: 10px 0;
      background-color: #f9f9f9;
    }
    .signature-section {
      margin-top: 20px;
      border-top: 2px solid #000;
      padding-top: 12px;
    }
    .signature-box {
      display: inline-block;
      width: 48%;
text-align: center;
      vertical-align: top;
    }
    .signature-line {
      border-bottom: 1px solid #000;
      height: 35px;
      margin-bottom: 4px;
    }
    .footer {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #ccc;
      font-size: 8pt;
      color: #666;
      text-align: center;
    }
    .decision-box {
      border: 2px solid #000;
      padding: 10px;
      margin: 12px 0;
      background-color: #fff;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 9.5pt;
    }
    table td {
      padding: 4px 6px;
      border: 1px solid #999;
    }
    table td.label {
      font-weight: bold;
      width: 180px;
      background-color: #f0f0f0;
    }
    .compact {
      margin: 6px 0;
      font-size: 9pt;
    }
  </style>
</head>
<body>

<div class="header">
  WNIOSEK O UDZIELENIE URLOPU WYPOCZYNKOWEGO
</div>

<div class="section">
  <div class="field">
    <span class="field-label">Imiƒô i nazwisko:</span>
    <span class="field-value"><strong>${request.name}</strong></span>
  </div>
  <div class="field">
    <span class="field-label">Login:</span>
    <span class="field-value">${request.login}</span>
  </div>
  <div class="field">
    <span class="field-label">Data z≈Ço≈ºenia wniosku:</span>
    <span class="field-value">${request.dateSubmitted}</span>
  </div>
</div>

<div class="box">
  <div style="font-weight: bold; margin-bottom: 8px;">Proszƒô o udzielenie urlopu wypoczynkowego:</div>
  
  <table>
    <tr>
      <td class="label">Od dnia:</td>
      <td><strong>${request.dateFrom}</strong></td>
    </tr>
    <tr>
      <td class="label">Do dnia:</td>
      <td><strong>${request.dateTo}</strong></td>
    </tr>
    <tr>
      <td class="label">Liczba dni roboczych:</td>
      <td><strong>${request.workingDays} dni</strong></td>
    </tr>
    <tr>
      <td class="label">Typ urlopu:</td>
      <td>${typeLabel}</td>
    </tr>
  </table>
  
  ${request.commentEmployee ? `
  <div class="compact">
    <strong>Uwagi pracownika:</strong> <em>${request.commentEmployee}</em>
  </div>
  ` : ''}
</div>

<div class="section">
  <div style="font-weight: bold; margin-bottom: 8px;">Stan urlopowy na dzie≈Ñ z≈Ço≈ºenia wniosku:</div>
  
  <table>
    <tr>
      <td class="label">Urlop przys≈ÇugujƒÖcy (rok bie≈ºƒÖcy):</td>
      <td>${balance.przys≈ÇugujƒÖcy} dni</td>
    </tr>
    <tr>
      <td class="label">Urlop zaleg≈Çy (lata ubieg≈Çe):</td>
      <td>${balance.zaleg≈Çy} dni</td>
    </tr>
    <tr>
      <td class="label">Urlop wykorzystany:</td>
      <td>${balance.wykorzystany} dni</td>
    </tr>
    <tr>
      <td class="label">Urlop pozosta≈Çy:</td>
      <td><strong>${balance.pozosta≈Çy} dni</strong></td>
    </tr>
  </table>
</div>

<div class="signature-section">
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracownika</div>
  </div>
  
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracodawcy</div>
  </div>
</div>

${request.status !== 'OczekujƒÖcy' ? `
<div class="decision-box">
  <div style="font-weight: bold; margin-bottom: 8px;">Decyzja pracodawcy:</div>
  
  <div class="compact">
    ${statusLabel}
  </div>
  <div class="compact">
    ${statusReject}
  </div>
  
  ${request.commentManager ? `
  <div class="compact" style="margin-top: 8px;">
    <strong>Uwagi kierownika:</strong> <em>${request.commentManager}</em>
  </div>
  ` : ''}
  
  ${request.dateDecision ? `
  <div class="compact">
    <strong>Data decyzji:</strong> ${request.dateDecision}
  </div>
  ` : ''}
</div>
` : ''}

<div class="footer">
  Wniosek nr: ${request.id} | Wygenerowano: ${Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd HH:mm')}<br>
  System Magazynowy - Rejestrator Czasu Pracy
</div>

</body>
</html>
  `;
  
  return html;
}

function createDownloadUrl(pdfBlob) {
  const tempFolder = DriveApp.getRootFolder();
  const file = tempFolder.createFile(pdfBlob);
  
  file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
  
  const url = file.getDownloadUrl();
  
  return url;
}

// ===== FUNKCJA USTAWIAJƒÑCA TRIGGER =====

/**
 * Ustawia automatyczny trigger uruchamiajƒÖcy raport codziennie o 03:00
 * URUCHOM Tƒò FUNKCJƒò RAZ aby skonfigurowaƒá automatyzacjƒô
 */
function setupDailyReportTrigger() {
  // Usu≈Ñ istniejƒÖce triggery dla tej funkcji (je≈õli sƒÖ)
  const triggers = ScriptApp.getProjectTriggers();
  for (let i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === 'autoRefreshCurrentMonthReport') {
      ScriptApp.deleteTrigger(triggers[i]);
      console.log('Usuniƒôto stary trigger');
    }
  }
  
  // Utw√≥rz nowy trigger - codziennie o 03:00
  ScriptApp.newTrigger('autoRefreshCurrentMonthReport')
    .timeBased()
    .atHour(3)  // Godzina 03:00
    .everyDays(1)  // Codziennie
    .inTimezone('Europe/Warsaw')  // Strefa czasowa
    .create();
  
  console.log('‚úÖ Trigger zosta≈Ç ustawiony!');
  console.log('Raport bƒôdzie od≈õwie≈ºany codziennie o 03:00');
  
  return {
    success: true,
    message: 'Automatyczne od≈õwie≈ºanie zosta≈Ço skonfigurowane na 03:00'
  };
}

// ===== FUNKCJA WYWO≈ÅYWANA PRZEZ TRIGGER =====

/**
 * Ta funkcja jest automatycznie uruchamiana przez trigger o 03:00
 * Od≈õwie≈ºa raport za bie≈ºƒÖcy miesiƒÖc na podstawie cache
 */
function autoRefreshCurrentMonthReport() {
  try {
    console.log('=== AUTO-OD≈öWIE≈ªANIE RAPORTU (03:00) ===');
    console.log('Czas wykonania:', new Date().toISOString());
    
    // Wywo≈Çaj istniejƒÖcƒÖ funkcjƒô od≈õwie≈ºania
    const result = refreshCurrentMonthReport();
    
    console.log('‚úÖ Raport od≈õwie≈ºony pomy≈õlnie');
    console.log('Szczeg√≥≈Çy:', result);
    
    // Opcjonalnie: wy≈õlij email z potwierdzeniem
    // sendReportNotification(result);
    
    return result;
    
  } catch (error) {
    console.error('‚ùå B≈ÅƒÑD podczas automatycznego od≈õwie≈ºania:', error);
    
    // Opcjonalnie: wy≈õlij email z alertem o b≈Çƒôdzie
    // sendErrorNotification(error);
    
    throw error;
  }
}

// ============================================
// DASHBOARD - FUNKCJE POMOCNICZE
// ============================================

/**
 * Pobiera dzisiejsze logi z arkusza Logi
 */
function getTodayLogs(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  const data = logsSheet.getDataRange().getValues();
  
  const logs = [];
  for (let i = 1; i < data.length; i++) {
    if (!data[i][1]) continue; // Brak daty
    
    const rowDate = Utilities.formatDate(
      new Date(data[i][1]), 
      'Europe/Warsaw', 
      'yyyy-MM-dd'
    );
    
    if (rowDate === date) {
      logs.push({
        login: data[i][2],
        timestamp: data[i][1],
        department: data[i][4],
        action: data[i][6],
        status: data[i][7]
      });
    }
  }
  
  console.log(`Znaleziono ${logs.length} log√≥w na dzie≈Ñ ${date}`);
  return logs;
}

/**
 * Pobiera dzisiejsze urlopy z arkusza Wnioski_urlopowe
 */
function getTodayVacations(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const vacSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = vacSheet.getDataRange().getValues();
  
  const vacations = [];
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, , dateFrom, dateTo, days, status, type] = data[i];
    
    if (status === 'Zatwierdzony' && dateFrom && dateTo) {
      const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
      const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');
      
      if (date >= from && date <= to) {
        vacations.push({ 
          login: login, 
          type: type || 'Planowany' 
        });
      }
    }
  }
  
  console.log(`Znaleziono ${vacations.length} urlop√≥w na dzie≈Ñ ${date}`);
  return vacations;
}

/**
 * Pobiera dzisiejsze wnioski urlopowe w statusie OczekujƒÖcy (z≈Ço≈ºone, niezatwierdzone)
 */
function getTodayVacationRequestsPending(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const vacSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = vacSheet.getDataRange().getValues();

  const pending = [];
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, , dateFrom, dateTo, days, status, type] = data[i];

    if (status === 'OczekujƒÖcy' && dateFrom && dateTo) {
      const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
      const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');

      if (date >= from && date <= to) {
        pending.push({
          login: login,
          type: type || 'Planowany'
        });
      }
    }
  }

  console.log(`Znaleziono ${pending.length} wniosk√≥w oczekujƒÖcych na dzie≈Ñ ${date}`);
  return pending;
}

/**
 * Pobiera dzisiejsze zwolnienia lekarskie (L4)
 */
function getTodayL4(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const l4Sheet = ss.getSheetByName(SHEETS.L4 || 'Zwolnienia_lekarskie');

  if (!l4Sheet) {
    console.log('Brak arkusza Zwolnienia_lekarskie');
    return [];
  }

  const data = l4Sheet.getDataRange().getValues();
  const l4List = [];

  for (let i = 1; i < data.length; i++) {
    const [id, login, name, dateFrom, dateTo, days, status, type, note] = data[i];

    // jedyny warunek: musi byƒá login i zakres dat
    if (!login || !dateFrom || !dateTo) continue;

    const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
    const to   = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');

    // decydujƒÖ WY≈ÅƒÑCZNIE daty
    if (date >= from && date <= to) {
      l4List.push({
        login: String(login).trim(),
        name: name,
        type: type || 'Choroba',
        dateFrom: from,
        dateTo: to,
        status: status
      });
    }
  }

  console.log(`Znaleziono ${l4List.length} L4 na dzie≈Ñ ${date}`);
  return l4List;
}

function testL4() {
  Logger.log(getTodayL4('2026-02-12'));
}

/**
 * Pobiera dzisiejsze zatwierdzone dni wolne
 */
function getTodayDayOff(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const dayOffSheet = ss.getSheetByName('Dni_wolne');
  
  if (!dayOffSheet) {
    console.log('Brak arkusza Dni_wolne');
    return [];
  }
  
  const data = dayOffSheet.getDataRange().getValues();
  const dayOffList = [];
  
  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data, F=Typ, 
    // G=Godzina_od, H=Godzina_do, I=Powod, J=Status
    const login = data[i][1];
    const name = data[i][2];
    const dayOffDate = data[i][4];
    const type = data[i][5];
    const status = data[i][9];
    
    if (!login || status !== 'Zatwierdzony') continue;
    
    if (dayOffDate) {
      const formattedDate = Utilities.formatDate(new Date(dayOffDate), 'Europe/Warsaw', 'yyyy-MM-dd');
      
      if (formattedDate === date) {
        dayOffList.push({ 
          login: login,
          name: name,
          type: type || 'Dzie≈Ñ wolny'
        });
      }
    }
  }
  
  console.log(`Znaleziono ${dayOffList.length} dni wolnych na dzie≈Ñ ${date}`);
  return dayOffList;
}

function getTodayDayOffPending(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Dni_wolne');
  if (!sheet) {
    console.log('Brak arkusza Dni_wolne');
    return [];
  }

  const data = sheet.getDataRange().getValues();
  const out = [];

  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imiƒô_Nazwisko, D=Data_zlozenia, E=Data, F=Typ, ...
    const login = data[i][1];
    const name = data[i][2];
    const day = data[i][4];        // kolumna "Data"
    const type = data[i][5];       // kolumna "Typ"
    const status = data[i][9];     // kolumna "Status" (wg Twojego uk≈Çadu na screenie)

    if (!login || !day) continue;
    if (String(status || '').trim() !== 'OczekujƒÖcy') continue;

    const dayISO = Utilities.formatDate(new Date(day), 'Europe/Warsaw', 'yyyy-MM-dd');

    if (date === dayISO) {
      out.push({
        login: String(login).trim(),
        name: name,
        type: type || 'Dzie≈Ñ wolny',
        date: dayISO,
        status: status
      });
    }
  }

  console.log(`Znaleziono ${out.length} dni wolnych OCZEKUJƒÑCYCH na dzie≈Ñ ${date}`);
  return out;
}

/**
 * Pobiera dzisiejsze zatwierdzone urlopy okoliczno≈õciowe
 */
function getTodayOccasionalLeave(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
  
  if (!occasionalSheet) {
    console.log('Brak arkusza Urlopy_okolicznosciowe');
    return [];
  }
  
  const data = occasionalSheet.getDataRange().getValues();
  const occasionalList = [];
  
  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data_od, F=Data_do, 
    // G=Dni, H=Typ_wydarzenia, I=Notatka, J=Status
    const login = data[i][1];
    const name = data[i][2];
    const dateFrom = data[i][4];
    const dateTo = data[i][5];
    const type = data[i][7];
    const status = data[i][9];
    
    if (!login || status !== 'Zatwierdzony') continue;
    
    if (dateFrom && dateTo) {
      const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
      const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');
      
      // Sprawd≈∫ czy dzisiaj mie≈õci siƒô w zakresie
      if (date >= from && date <= to) {
        occasionalList.push({ 
          login: login,
          name: name,
          type: type || 'Urlop okoliczno≈õciowy',
          dateFrom: from,
          dateTo: to
        });
      }
    }
  }
  
  console.log(`Znaleziono ${occasionalList.length} urlop√≥w okoliczno≈õciowych na dzie≈Ñ ${date}`);
  return occasionalList;
}

function getTodayOccasionalLeavePending(date) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');

  if (!occasionalSheet) {
    console.log('Brak arkusza Urlopy_okolicznosciowe');
    return [];
  }

  const data = occasionalSheet.getDataRange().getValues();
  const occasionalList = [];

  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data_od, F=Data_do,
    // G=Dni, H=Typ_wydarzenia, I=Notatka, J=Status
    const login = data[i][1];
    const name = data[i][2];
    const dateFrom = data[i][4];
    const dateTo = data[i][5];
    const type = data[i][7];
    const status = data[i][9];

    if (!login || status !== 'OczekujƒÖcy') continue;

    if (dateFrom && dateTo) {
      const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
      const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');

      if (date >= from && date <= to) {
        occasionalList.push({
          login: login,
          name: name,
          type: type || 'Urlop okoliczno≈õciowy',
          dateFrom: from,
          dateTo: to,
          status: status
        });
      }
    }
  }

  console.log(`Znaleziono ${occasionalList.length} urlop√≥w okoliczno≈õciowych OCZEKUJƒÑCYCH na dzie≈Ñ ${date}`);
  return occasionalList;
}

// ======================================================
// ===== PLAN OBSADY (ETAP 2) - DOSTƒòPNO≈öƒÜ NA TYDZIE≈É =====
// ======================================================

/**
 * Bezpieczne parsowanie daty ISO (yyyy-MM-dd) do Date bez przesuniƒôƒá strefy.
 */
function wfParseISODate(iso) {
  if (!iso) throw new Error('Brak daty ISO');
  // "T00:00:00" ≈ºeby nie ucieka≈Ço na poprzedni dzie≈Ñ przez strefy
  return new Date(String(iso).trim() + 'T00:00:00');
}

/**
 * Format Date -> yyyy-MM-dd (Warszawa)
 */
function wfToISO(dateObj) {
  return Utilities.formatDate(dateObj, 'Europe/Warsaw', 'yyyy-MM-dd');
}

/**
 * Zwraca mapƒô { login -> true } dla pracownik√≥w przypisanych do deptName w arkuszu Pracownicy
 * (≈∫r√≥d≈Ço prawdy: kolumna "Dzia≈Ç", login w kolumnie A / "Login")
 */
function wfGetDeptLoginsMap(deptName) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS); // "Pracownicy"
  if (!sheet) throw new Error('Nie znaleziono arkusza: ' + SHEETS.USERS);

  const data = sheet.getDataRange().getValues();
  if (!data || data.length < 2) return {};

  const headersRaw = data[0].map(h => String(h || '').trim());

  const norm = (s) => String(s || '')
    .trim()
    .toLowerCase()
    .replace(/ƒÖ/g,'a').replace(/ƒá/g,'c').replace(/ƒô/g,'e').replace(/≈Ç/g,'l')
    .replace(/≈Ñ/g,'n').replace(/√≥/g,'o').replace(/≈õ/g,'s').replace(/≈º/g,'z').replace(/≈∫/g,'z');

  const headers = headersRaw.map(norm);

  // login mo≈ºe byƒá "login" albo brak nag≈Ç√≥wka -> fallback kol A
  let idxLogin = headers.indexOf('login');
  if (idxLogin === -1) idxLogin = 0;

  // dzia≈Ç (na przysz≈Ço≈õƒá)
  let idxDept = headers.indexOf('dzial');
  if (idxDept === -1) idxDept = headers.findIndex(h => h.includes('dzial')); // awaryjnie

  const deptInput = String(deptName || '').trim();
  const useAll = !deptInput || deptInput.toUpperCase() === 'ALL';

  // sta≈Ça: wykluczenia (kierownik itp.)
  const EXCLUDED_LOGINS = new Set(['jerzyd']);

  const map = {};

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const login = row[idxLogin] ? String(row[idxLogin]).trim() : '';
    if (!login) continue;
    if (EXCLUDED_LOGINS.has(login)) continue;

    if (useAll) {
      map[login] = true;
      continue;
    }

    // je≈õli jednak liczymy po dziale, to musimy mieƒá kolumnƒô dzia≈Ç
    if (idxDept === -1) throw new Error('Nie znaleziono kolumny dzia≈Ç/dzial w arkuszu Pracownicy');

    const rowDept = row[idxDept] ? String(row[idxDept]).trim() : '';
    if (rowDept === deptInput) {
      map[login] = true;
    }
  }

  return map;
}

/**
 * getWorkforceAvailabilityWeek(deptName, mondayDateISO)
 * Zwraca dostƒôpno≈õƒá Pon‚ÄìPt dla dzia≈Çu:
 * dostƒôpni = wszyscy z Pracownicy(Dzia≈Ç) minus (zatwierdzone urlopy + aktywne L4 + zatwierdzone dni wolne)
 */
function getWorkforceAvailabilityWeek(deptName, mondayDateISO) {
  sprawdzUprawnienia();

  const dept = String(deptName || '').trim();
  const mon = wfParseISODate(mondayDateISO);

  // Budujemy Pon‚ÄìPt (5 dni)
  const dates = [];
  for (let i = 0; i < 5; i++) {
    const d = new Date(mon);
    d.setDate(d.getDate() + i);
    dates.push(d);
  }

  const weekISO = {
    mon: wfToISO(dates[0]),
    tue: wfToISO(dates[1]),
    wed: wfToISO(dates[2]),
    thu: wfToISO(dates[3]),
    fri: wfToISO(dates[4])
  };

  // Pracownicy dzia≈Çu
  const deptLoginsMap = wfGetDeptLoginsMap(dept);
  const deptLogins = Object.keys(deptLoginsMap);
  const totalEmployees = deptLogins.length;

  // Helper: filtruj listƒô nieobecno≈õci do login√≥w dzia≈Çu
  const filterToDept = (list) => {
    if (!Array.isArray(list)) return [];
    return list
      .map(x => (x && x.login) ? String(x.login).trim() : '')
      .filter(l => l && deptLoginsMap[l]);
  };

  const dayNames = [
    { key: 'Pon', iso: weekISO.mon },
    { key: 'Wto', iso: weekISO.tue },
    { key: '≈öro', iso: weekISO.wed },
    { key: 'Czw', iso: weekISO.thu },
    { key: 'PiƒÖ', iso: weekISO.fri }
  ];

  const days = {};
  for (const day of dayNames) {
    const dateISO = day.iso;

    // Pewne (zatwierdzone/aktywne)
    const vacAll = getTodayVacations(dateISO);
    const l4All = getTodayL4(dateISO);
    const dayOffAll = getTodayDayOff(dateISO);              // ‚úÖ DZIE≈É WOLNY (Zatwierdzony)
    const occAll = getTodayOccasionalLeave(dateISO);

    // OczekujƒÖce
    const pendingVacAll = getTodayVacationRequestsPending(dateISO);
    const occPendingAll = getTodayOccasionalLeavePending(dateISO);
    const dayOffPendingAll = getTodayDayOffPending(dateISO); // ‚úÖ DZIE≈É WOLNY (OczekujƒÖcy)

    const vacLogins = filterToDept(vacAll);
    const l4Logins = filterToDept(l4All);
    const dayOffLogins = filterToDept(dayOffAll);          // ‚úÖ
    const occLogins = filterToDept(occAll);

    const pendingVacLogins = filterToDept(pendingVacAll);
    const occPendingLogins = filterToDept(occPendingAll);
    const dayOffPendingLogins = filterToDept(dayOffPendingAll); // ‚úÖ

    // Zbiory unikalne (pewne)
    const vacSet = new Set(vacLogins);
    const l4Set = new Set(l4Logins);
    const dayOffSet = new Set(dayOffLogins);               // ‚úÖ
    const occSet = new Set(occLogins);

    const absentSet = new Set();
    vacSet.forEach(x => absentSet.add(x));
    l4Set.forEach(x => absentSet.add(x));
    dayOffSet.forEach(x => absentSet.add(x));              // ‚úÖ
    occSet.forEach(x => absentSet.add(x));

    const absentConfirmed = absentSet.size;
    const availableConfirmed = Math.max(0, totalEmployees - absentConfirmed);

    // Zbiory unikalne (ostro≈ºnie = pewne + oczekujƒÖce)
    const pendingVacSet = new Set(pendingVacLogins);
    const occPendingSet = new Set(occPendingLogins);
    const dayOffPendingSet = new Set(dayOffPendingLogins); // ‚úÖ

    const absentConservativeSet = new Set(absentSet);
    pendingVacSet.forEach(x => absentConservativeSet.add(x));
    occPendingSet.forEach(x => absentConservativeSet.add(x));
    dayOffPendingSet.forEach(x => absentConservativeSet.add(x)); // ‚úÖ

    const absentConservative = absentConservativeSet.size;
    const availableConservative = Math.max(0, totalEmployees - absentConservative);

    // ‚úÖ Jedna liczba "oczekujƒÖce"
    const totalPending = pendingVacSet.size + occPendingSet.size + dayOffPendingSet.size;

    days[day.key] = {
      date: dateISO,

      // kompatybilno≈õƒá wstecz
      available: availableConfirmed,
      absent: absentConfirmed,

      availableConfirmed: availableConfirmed,
      absentConfirmed: absentConfirmed,

      availableConservative: availableConservative,
      absentConservative: absentConservative,

      absentBreakdown: {
        vac: vacSet.size,
        l4: l4Set.size,
        dayoff: dayOffSet.size,     // ‚úÖ DZIE≈É WOLNY (zatwierdzone)
        occ: occSet.size
      },

      pendingBreakdown: {
        totalPending: totalPending, // ‚úÖ jedna liczba
        // debug (nie musisz tego nigdzie pokazywaƒá)
        vacPending: pendingVacSet.size,
        occPending: occPendingSet.size,
        dayOffPending: dayOffPendingSet.size
      }
    };
  }

  return {
    deptName: dept,
    week: {
      mon: weekISO.mon,
      tue: weekISO.tue,
      wed: weekISO.wed,
      thu: weekISO.thu,
      fri: weekISO.fri
    },
    totals: { totalEmployees: totalEmployees },
    days: days
  };
}

// ===== PLANOWANIE OBSADY (ETAP 3) ‚Äî zapis planu + historia =====

const WF_PLAN_SHEET = 'Plan_obsady';

function wfGetOrCreatePlanSheet_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName(WF_PLAN_SHEET);
  if (!sh) {
    sh = ss.insertSheet(WF_PLAN_SHEET);
    sh.appendRow([
      'timestamp',
      'week_monday',
      'dept',
      'mode',
      'include_pending',
      'weekly_orders',
      'productivity',
      'p_mon','p_tue','p_wed','p_thu','p_fri',
      'h_mon','h_tue','h_wed','h_thu','h_fri',
      'av_mon','av_tue','av_wed','av_thu','av_fri',
      'balance_hours',
      'shortage_hours',
      'surplus_hours',
      'payload_json'
    ]);
    sh.setFrozenRows(1);
  }
  return sh;
}

function initPlanObsadySheet() {
  sprawdzUprawnienia();
  wfGetOrCreatePlanSheet_();
}

function wfNormISO_(v){
  if (!v) return '';
  if (Object.prototype.toString.call(v) === '[object Date]' && !isNaN(v.getTime())) {
    const yyyy = v.getFullYear();
    const mm = String(v.getMonth()+1).padStart(2,'0');
    const dd = String(v.getDate()).padStart(2,'0');
    return `${yyyy}-${mm}-${dd}`;
  }
  // je≈õli to string
  const s = String(v).trim();
  // bierzemy pierwsze 10 znak√≥w je≈õli wyglƒÖda jak ISO
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0,10);
  return s;
}

// ===== AGENCJE ‚Äî pobieranie listy z arkusza =====
const WF_AGENCIES_SHEET = 'Agencje';

function wfGetActiveAgencies() {
  sprawdzUprawnienia();

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(WF_AGENCIES_SHEET);
  if (!sh) throw new Error('Brak arkusza: Agencje');

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return [];

  const values = sh.getRange(2, 1, lastRow - 1, 5).getValues(); // A:E
  const out = [];

  values.forEach(r => {
    const active = String(r[0] || '').trim().toUpperCase(); // A
    const name   = String(r[1] || '').trim();              // B
    const email  = String(r[2] || '').trim();              // C
    const cc     = String(r[3] || '').trim();              // D
    const note   = String(r[4] || '').trim();              // E

    if (active === 'TAK' && name && email) {
      out.push({ name, email, cc, note });
    }
  });

  return out;
}

function saveWorkforcePlan(plan) {
  sprawdzUprawnienia();

  if (!plan || typeof plan !== 'object') throw new Error('Brak danych planu.');
  if (!plan.weekMonday) throw new Error('Brak weekMonday.');
  if (!plan.dept) throw new Error('Brak dept.');

  const sh = wfGetOrCreatePlanSheet_();

  const weekMonday = String(plan.weekMonday).trim();   // yyyy-mm-dd
  const dept = String(plan.dept).trim();

  const mode = String(plan.mode || 'AUTO').trim();
  const includePending = !!plan.includePending;

  const weeklyOrders = Number(plan.weeklyOrders || 0);
  const productivity = Number(plan.productivity || 1);

  const p = plan.percent || {};
  const h = plan.hours || {};
  const a = plan.avail || {};

  const balanceHours = Number(plan.balanceHours || 0);
  const shortageHours = Number(plan.shortageHours || 0);
  const surplusHours = Number(plan.surplusHours || 0);

  const payloadJson = JSON.stringify(plan);

    // upsert po (week_monday + dept) ‚Äî odporne na Date/tekst + r√≥≈ºne formaty
    const lastRow = sh.getLastRow();
    let targetRow = null;

    const normDept = String(dept).trim().toUpperCase();
    const normWeek = wfNormISO_(weekMonday);

    if (lastRow >= 2) {
      const data = sh.getRange(2, 2, lastRow - 1, 2).getValues(); // B:C
      for (let i = 0; i < data.length; i++) {
        const cellWeek = wfNormISO_(data[i][0]);
        const cellDept = String(data[i][1] || '').trim().toUpperCase();
        if (cellWeek === normWeek && cellDept === normDept) {
          targetRow = i + 2;
          break;
        }
      }
    }

  const rowValues = [
    new Date(),
    weekMonday,
    dept,
    mode,
    includePending ? 'TAK' : 'NIE',
    weeklyOrders,
    productivity,
    Number(p.Pon || 0), Number(p.Wt || 0), Number(p['≈ör'] || 0), Number(p.Czw || 0), Number(p.Pt || 0),
    Number(h.Pon || 0), Number(h.Wt || 0), Number(h['≈ör'] || 0), Number(h.Czw || 0), Number(h.Pt || 0),
    Number(a.Pon || 0), Number(a.Wt || 0), Number(a['≈ör'] || 0), Number(a.Czw || 0), Number(a.Pt || 0),
    balanceHours,
    shortageHours,
    surplusHours,
    payloadJson
  ];

  if (targetRow) {
    sh.getRange(targetRow, 1, 1, rowValues.length).setValues([rowValues]);
    return { ok: true, action: 'updated', row: targetRow };
  } else {
    sh.appendRow(rowValues);
    return { ok: true, action: 'inserted', row: sh.getLastRow() };
  }
}

function getWorkforcePlan(deptName, mondayDateISO) {
  sprawdzUprawnienia();

  const sh = wfGetOrCreatePlanSheet_();
  const weekMonday = String(mondayDateISO || '').trim();
  const dept = String(deptName || '').trim();
  if (!weekMonday || !dept) return null;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return null;

  const data = sh.getRange(2, 1, lastRow - 1, 25).getValues(); // A:Y
  // payload_json jest w kolumnie Z (26)
  const jsonCol = sh.getRange(2, 26, lastRow - 1, 1).getValues();

  for (let i = 0; i < data.length; i++) {
    const rowWeek = String(data[i][1] || '').trim(); // B
    const rowDept = String(data[i][2] || '').trim(); // C
    if (rowWeek === weekMonday && rowDept === dept) {
      const raw = String((jsonCol[i] && jsonCol[i][0]) ? jsonCol[i][0] : '').trim();
      if (!raw) return null;
      try { return JSON.parse(raw); } catch(e) { return null; }
    }
  }
  return null;
}

function getPreviousWorkforcePlan(deptName, mondayDateISO) {
  sprawdzUprawnienia();

  const sh = wfGetOrCreatePlanSheet_();
  const dept = String(deptName || '').trim();
  const mon = wfParseISODate(mondayDateISO); // mamy ju≈º helper w Twoim GS
  if (!dept || !mon) return null;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return null;

  const data = sh.getRange(2, 1, lastRow - 1, 3).getValues(); // A:C (timestamp, week, dept)
  const jsonCol = sh.getRange(2, 26, lastRow - 1, 1).getValues();

  let bestIdx = -1;
  let bestDate = null;

  for (let i = 0; i < data.length; i++) {
    const rowWeek = String(data[i][1] || '').trim();
    const rowDept = String(data[i][2] || '').trim();
    if (rowDept !== dept) continue;

    const rowDate = wfParseISODate(rowWeek);
    if (!rowDate) continue;

    if (rowDate.getTime() < mon.getTime()) {
      if (!bestDate || rowDate.getTime() > bestDate.getTime()) {
        bestDate = rowDate;
        bestIdx = i;
      }
    }
  }

  if (bestIdx === -1) return null;

  const raw = String((jsonCol[bestIdx] && jsonCol[bestIdx][0]) ? jsonCol[bestIdx][0] : '').trim();
  if (!raw) return null;
  try { return JSON.parse(raw); } catch(e) { return null; }
}

function getWorkforceDepartments() {
  sprawdzUprawnienia();

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(SHEETS.USERS); // "Pracownicy"
  if (!sheet) throw new Error('Nie znaleziono arkusza: ' + SHEETS.USERS);

  const data = sheet.getDataRange().getValues();
  if (!data || data.length < 2) return ['ALL'];

  const headersRaw = data[0].map(h => String(h || '').trim());

  const norm = (s) => String(s || '')
    .trim()
    .toLowerCase()
    .replace(/ƒÖ/g,'a').replace(/ƒá/g,'c').replace(/ƒô/g,'e').replace(/≈Ç/g,'l')
    .replace(/≈Ñ/g,'n').replace(/√≥/g,'o').replace(/≈õ/g,'s').replace(/≈º/g,'z').replace(/≈∫/g,'z');

  const headers = headersRaw.map(norm);

  let idxDept = headers.indexOf('dzial');
  if (idxDept === -1) idxDept = headers.findIndex(h => h.includes('dzial'));

  // jak nie ma kolumny dzia≈Ç -> zostaw tylko ALL
  if (idxDept === -1) return ['ALL'];

  const set = new Set();

  for (let i = 1; i < data.length; i++) {
    const v = data[i][idxDept];
    const dept = String(v || '').trim();
    if (!dept) continue;
    set.add(dept);
  }

  const list = Array.from(set).sort((a,b) => a.localeCompare(b, 'pl'));
  // ALL zawsze na g√≥rze
  return ['ALL', ...list];
}

/**
 * TEST (odpal w edytorze Apps Script)
 * Uwaga: wpisz dzia≈Ç dok≈Çadnie jak w arkuszu Pracownicy (kolumna "Dzia≈Ç")
 */
function testWorkforceWeek() {
  const deptName = 'ALL';

  // Bierzemy "dzisiejszƒÖ" datƒô i cofamy do poniedzia≈Çku tego tygodnia
  const today = new Date();
  today.setHours(0,0,0,0);

  const day = today.getDay(); // nd=0, pon=1 ... sob=6
  const diffToMonday = (day === 0) ? 6 : (day - 1);

  const monday = new Date(today);
  monday.setDate(monday.getDate() - diffToMonday);

  const mondayISO = wfToISO(monday);

  Logger.log('üß™ testWorkforceWeek -> dept=' + deptName + ', monday=' + mondayISO);

  const result = getWorkforceAvailabilityWeek(deptName, mondayISO);
  Logger.log(JSON.stringify(result, null, 2));

  return result;
}

/**
 * Grupuje pracownik√≥w wed≈Çug zmian (godzina_start-godzina_koniec)
 */
function groupWorkersByShift(workers) {
  const shifts = {};
  
  workers.forEach(worker => {
    if (!worker.startTime || !worker.endTime) return;
    
    const shiftKey = `${worker.startTime}-${worker.endTime}`;
    
    if (!shifts[shiftKey]) {
      shifts[shiftKey] = {
        start: worker.startTime,
        end: worker.endTime,
        planned: [],
        present: 0,
        onBreak: 0,
        absent: 0,
        vacation: 0,
        left: 0
      };
    }
    
    shifts[shiftKey].planned.push(worker);
  });
  
  console.log(`Pogrupowano pracownik√≥w na ${Object.keys(shifts).length} zmian`);
  return shifts;
}

/**
 * Oblicza status pojedynczego pracownika
 */
function calculateWorkerStatus(worker, todayLogs, vacations, l4List, dayOffList, occasionalList) {
  // 1. NAJWY≈ªSZY PRIORYTET - Sprawd≈∫ L4
const onL4 = l4List.find(l4 => l4.login === worker.login);
if (onL4) {
  // Okre≈õl status L4 na podstawie dat
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const l4Start = new Date(onL4.dateFrom);
  l4Start.setHours(0, 0, 0, 0);
  const l4End = new Date(onL4.dateTo);
  l4End.setHours(0, 0, 0, 0);
  
  let l4Status = 'Zaplanowane';
  if (today >= l4Start && today <= l4End) {
    l4Status = 'Trwa';
  } else if (today > l4End) {
    l4Status = 'Zako≈Ñczone';
  }
  
  return {
    login: worker.login,
    name: worker.name,
    statusKey: 'l4',
    statusText: `L4 (${l4Status})`,
    statusIcon: 'üè•',
    department: worker.dept,
    l4Type: onL4.type,
    l4DateFrom: onL4.dateFrom,
    l4DateTo: onL4.dateTo,
    l4Status: l4Status
  };
}
  
  // 2. Sprawd≈∫ czy na urlopie
  const onVacation = vacations.find(v => v.login === worker.login);
  if (onVacation) {
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'vacation',
      statusText: 'URLOP',
      statusIcon: 'üèñÔ∏è',
      department: worker.dept,
      vacationType: onVacation.type
    };
  }
  
  // 3. Sprawd≈∫ czy ma urlop okoliczno≈õciowy (PRZED dniami wolnymi - wy≈ºszy priorytet)
  const onOccasional = occasionalList ? occasionalList.find(o => o.login === worker.login) : null;
  if (onOccasional) {
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'occasional',
      statusText: 'URLOP OKOL.',
      statusIcon: 'üéä',
      department: worker.dept,
      occasionalType: onOccasional.type
    };
  }
  
  // 4. Sprawd≈∫ czy ma dzie≈Ñ wolny
  const onDayOff = dayOffList ? dayOffList.find(d => d.login === worker.login) : null;
  if (onDayOff) {
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'dayoff',
      statusText: 'DZIE≈É WOLNY',
      statusIcon: 'üìÖ',
      department: worker.dept,
      dayOffType: onDayOff.type
    };
  }
  
  // 5. Sprawd≈∫ dzisiejsze logi pracownika
  const workerLogs = todayLogs.filter(log => log.login === worker.login);
  
  if (workerLogs.length === 0) {
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'absent',
      statusText: 'NIEOBECNY',
      statusIcon: '‚ùå',
      department: worker.dept
    };
  }
  
  // 3. Znajd≈∫ ostatniƒÖ akcjƒô
  const lastLog = workerLogs[workerLogs.length - 1];
  
  // 4. Okre≈õl status na podstawie ostatniej akcji
  if (lastLog.status === 'Pracuje') {
    const workTime = calculateWorkTimeFromLogs(workerLogs);
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'working',
      statusText: 'PRACUJE',
      statusIcon: 'üü¢',
      currentDepartment: lastLog.department,
      workTime: workTime
    };
  }
  
  if (lastLog.status === 'Na przerwie') {
    const breakTime = calculateBreakTimeFromLog(lastLog.timestamp);
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'onBreak',
      statusText: 'PRZERWA',
      statusIcon: 'üü°',
      currentDepartment: lastLog.department,
      breakTime: breakTime
    };
  }
  
  if (lastLog.status === 'Nieaktywny') {
    return {
      login: worker.login,
      name: worker.name,
      statusKey: 'left',
      statusText: 'WYSZED≈Å',
      statusIcon: '‚ö™',
      department: worker.dept,
      exitTime: Utilities.formatDate(lastLog.timestamp, 'Europe/Warsaw', 'HH:mm')
    };
  }
  
  // Domy≈õlnie nieobecny
  return {
    login: worker.login,
    name: worker.name,
    statusKey: 'absent',
    statusText: 'NIEOBECNY',
    statusIcon: '‚ùå',
    department: worker.dept
  };
}

/**
 * Oblicza czas pracy z log√≥w (w minutach)
 */
function calculateWorkTimeFromLogs(logs) {
  let totalMinutes = 0;
  let lastStart = null;
  
  logs.forEach(log => {
    if (log.action === 'Wchodzƒô do pracy' || log.action === 'Wracam z przerwy') {
      lastStart = log.timestamp;
    } else if (log.action === 'Wychodzƒô na przerwƒô' || log.action === 'Wychodzƒô z pracy') {
      if (lastStart) {
        const diff = (log.timestamp - lastStart) / 1000 / 60; // minuty
        totalMinutes += diff;
        lastStart = null;
      }
    }
  });
  
  // Je≈õli ostatnia akcja to start i nadal pracuje
  if (lastStart) {
    const now = new Date();
    const diff = (now - lastStart) / 1000 / 60;
    totalMinutes += diff;
  }
  
  const hours = Math.floor(totalMinutes / 60);
  const mins = Math.floor(totalMinutes % 60);
  return `${hours}:${mins.toString().padStart(2, '0')}h`;
}

/**
 * Oblicza czas przerwy (w minutach)
 */
function calculateBreakTimeFromLog(breakStart) {
  const now = new Date();
  const diff = (now - breakStart) / 1000 / 60;
  return Math.floor(diff);
}

/**
 * Oblicza status ca≈Çej zmiany (obsada, obecni, nieobecni)
 */
function calculateShiftStatus(shift, todayLogs, vacations, l4List, dayOffList, occasionalList, currentTime) {
  const now = new Date();
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  
  // Parsuj godzinƒô rozpoczƒôcia zmiany
  const startTimeStr = shift.start.toString();
  const [startHour, startMinute] = startTimeStr.includes(':') 
    ? startTimeStr.split(':').map(Number)
    : [parseInt(startTimeStr), 0];
  
  // Sprawd≈∫ czy zmiana ju≈º siƒô rozpoczƒô≈Ça
  const shiftStarted = (currentHour > startHour) || 
                       (currentHour === startHour && currentMinute >= startMinute);
  
  if (!shiftStarted) {
    // Zmiana jeszcze nie rozpoczƒôta
    shift.started = false;
    shift.present = 0;
    shift.onBreak = 0;
    shift.absent = 0;
    shift.vacation = 0;
    shift.left = 0;
    shift.coverage = 0;
    shift.alert = '‚ö™';
    return shift;
  }
  
  shift.started = true;
  shift.l4 = 0;
  shift.dayOff = 0;        // ‚Üê NOWE
  shift.occasional = 0;    // ‚Üê NOWE

// Oblicz statusy dla ka≈ºdego pracownika w zmianie
shift.planned.forEach(worker => {
  const status = calculateWorkerStatus(worker, todayLogs, vacations, l4List, dayOffList, occasionalList);
  worker.currentStatus = status;
    
    // Agreguj statusy
if (status.statusKey === 'working') {
  shift.present++;
} else if (status.statusKey === 'onBreak') {
  shift.onBreak++;
  shift.present++;
} else if (status.statusKey === 'vacation') {
  shift.vacation++;
} else if (status.statusKey === 'l4') {
  shift.l4++;
} else if (status.statusKey === 'dayoff') {      // ‚Üê NOWE
  shift.dayOff++;
} else if (status.statusKey === 'occasional') {  // ‚Üê NOWE
  shift.occasional++;
} else if (status.statusKey === 'left') {
  shift.left++;
} else if (status.statusKey === 'absent') {
  shift.absent++;
}
  });
  
  // Oblicz obsadƒô % (bez os√≥b na wszystkich nieobecno≈õciach)
const totalWithoutAbsences = shift.planned.length - shift.vacation - shift.l4 - shift.dayOff - shift.occasional;
shift.coverage = totalWithoutAbsences > 0 
  ? Math.round((shift.present / totalWithoutAbsences) * 100) 
  : 0;
  
  // Okre≈õl kolor alertu
  if (shift.coverage >= 80) {
    shift.alert = 'üü¢';
  } else if (shift.coverage >= 50) {
    shift.alert = 'üü°';
  } else if (shift.coverage > 0) {
    shift.alert = 'üî¥';
  } else {
    shift.alert = '‚ö™';
  }
  
  return shift;
}

/**
 * Oblicza og√≥lny bilans wszystkich zmian
 */
function calculateOverallBalance(shifts) {
  let totalPlanned = 0;
  let totalPresent = 0;
  let totalVacation = 0;
  let totalL4 = 0;
  let totalDayOff = 0;      // ‚Üê NOWE
  let totalOccasional = 0;  // ‚Üê NOWE
  let totalAbsent = 0;
  let totalLeft = 0;
  
  Object.values(shifts).forEach(shift => {
    if (shift.started) {
      totalPlanned += shift.planned.length;
      totalPresent += shift.present;
      totalVacation += shift.vacation;
      totalL4 += shift.l4 || 0;
      totalDayOff += shift.dayOff || 0;          // ‚Üê NOWE
      totalOccasional += shift.occasional || 0;  // ‚Üê NOWE
      totalAbsent += shift.absent;
      totalLeft += shift.left;
    }
  });
  
  const totalWithoutAbsences = totalPlanned - totalVacation - totalL4 - totalDayOff - totalOccasional;
  const frekwencja = totalWithoutAbsences > 0
    ? Math.round((totalPresent / totalWithoutAbsences) * 100)
    : 0;
  
  return {
    planned: totalPlanned,
    present: totalPresent,
    vacation: totalVacation,
    l4: totalL4,
    dayOff: totalDayOff,          // ‚Üê NOWE
    occasional: totalOccasional,  // ‚Üê NOWE
    otherAbsences: totalDayOff + totalOccasional,  // ‚Üê ZBIORCZY LICZNIK
    absent: totalAbsent,
    left: totalLeft,
    frekwencja: frekwencja
  };
}

/**
 * G≈Å√ìWNA FUNKCJA - Pobiera wszystkie dane do dashboardu
 */
function getDashboardData() {
  sprawdzUprawnienia();
  
  console.log('=== GENEROWANIE DANYCH DASHBOARDU ===');
  
  const today = Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd');
  const now = new Date();
  
  // 1. Pobierz wszystkich pracownik√≥w z arkusza Pracownicy
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const userSheet = ss.getSheetByName(SHEETS.USERS);
  const userData = userSheet.getDataRange().getValues();
  
  const workers = [];
  for (let i = 1; i < userData.length; i++) {
    const login = userData[i][0];
    const code = userData[i][1];
    const name = userData[i][2];
    const dept = userData[i][3];
    const status = userData[i][4];
    const startTime = userData[i][5];  // Kolumna F
    const endTime = userData[i][6];    // Kolumna G
    if (login && startTime && endTime) {
      workers.push({
        login: login,
        code: code,
        name: name,
        dept: dept,
        status: status,
        startTime: startTime,
        endTime: endTime
      });
    }
  }
  
  console.log(`Pobrano ${workers.length} pracownik√≥w`);
  
  // 2. Pogrupuj pracownik√≥w wed≈Çug zmian
  const shifts = groupWorkersByShift(workers);
  
  // 3. Pobierz dzisiejsze dane
  const todayLogs = getTodayLogs(today);
  const vacations = getTodayVacations(today);
  const l4List = getTodayL4(today);
  const dayOffList = getTodayDayOff(today);           // ‚Üê NOWE
  const occasionalList = getTodayOccasionalLeave(today); // ‚Üê NOWE
  
  // 4. Oblicz statusy dla ka≈ºdej zmiany
Object.keys(shifts).forEach(shiftKey => {
  calculateShiftStatus(shifts[shiftKey], todayLogs, vacations, l4List, dayOffList, occasionalList, now);
});
  
  // 5. Oblicz og√≥lny bilans
  const overall = calculateOverallBalance(shifts);
  
  // 6. Posortuj zmiany wed≈Çug godziny rozpoczƒôcia
  const sortedShifts = Object.keys(shifts)
    .sort((a, b) => {
      const timeA = shifts[a].start.toString();
      const timeB = shifts[b].start.toString();
      return timeA.localeCompare(timeB);
    })
    .reduce((obj, key) => {
      obj[key] = shifts[key];
      return obj;
    }, {});
  
  console.log('=== DANE DASHBOARDU WYGENEROWANE ===');
  
  return {
    timestamp: Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd HH:mm:ss'),
    overall: overall,
    shifts: sortedShifts
  };
}

/**
 * FUNKCJA TESTOWA - uruchom jƒÖ rƒôcznie aby sprawdziƒá czy backend dzia≈Ça
 */
function testDashboard() {
  console.log('=== TEST DASHBOARDU ===');
  
  try {
    const data = getDashboardData();
    
    console.log('\n--- TIMESTAMP ---');
    console.log(data.timestamp);
    
    console.log('\n--- OG√ìLNY BILANS ---');
    console.log('Zaplanowano:', data.overall.planned);
    console.log('Obecni:', data.overall.present);
    console.log('Nieobecni:', data.overall.absent);
    console.log('Urlop:', data.overall.vacation);
    console.log('Wysz≈Ço:', data.overall.left);
    console.log('Frekwencja:', data.overall.frekwencja + '%');
    
    console.log('\n--- ZMIANY ---');
    Object.keys(data.shifts).forEach(shiftKey => {
      const shift = data.shifts[shiftKey];
      console.log(`\nZmiana ${shiftKey}:`);
      console.log(`  Rozpoczƒôta: ${shift.started ? 'TAK' : 'NIE'}`);
      if (shift.started) {
        console.log(`  Zaplanowano: ${shift.planned.length}`);
        console.log(`  Obecni: ${shift.present}`);
        console.log(`  Na przerwie: ${shift.onBreak}`);
        console.log(`  Nieobecni: ${shift.absent}`);
        console.log(`  Urlop: ${shift.vacation}`);
        console.log(`  Obsada: ${shift.coverage}% ${shift.alert}`);
      }
    });
    
    console.log('\n=== TEST ZAKO≈ÉCZONY SUKCESEM ===');
    return 'OK';
    
  } catch (error) {
    console.error('B≈ÅƒÑD:', error.toString());
    return 'ERROR: ' + error.toString();
  }
}

/**
 * Funkcja do wy≈õwietlania dashboardu jako Web App
 */
function doGet(e) {
  const page = e.parameter.page || 'rejestrator';
  
  if (page === 'dashboard') {
    return HtmlService.createHtmlOutputFromFile('dashboard')
      .setTitle('Dashboard - Kto jest w pracy')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  // Domy≈õlnie zwr√≥ƒá rejestrator
return HtmlService.createHtmlOutputFromFile('rejestrator')
  .setTitle('Rejestrator czasu pracy')
  .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function getWorkerStats() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getSheetByName("Dane");
  var data = sheet.getDataRange().getValues();
  
  var stats = {
    total: 0,
    onBreak: 0,
    byDepartment: {}
  };
  
  var today = new Date();
  today.setHours(0, 0, 0, 0);
  
  for (var i = 1; i < data.length; i++) {
    var loginTime = data[i][3]; // kolumna D - Godzina Logowania
    var logoutTime = data[i][4]; // kolumna E - Godzina Wylogowania
    var breakStart = data[i][5]; // kolumna F - PoczƒÖtek przerwy
    var department = data[i][2]; // kolumna C - Dzia≈Ç/Operacja
    
    if (loginTime && !logoutTime) {
      // Pracownik zalogowany
      stats.total++;
      
      if (breakStart) {
        // Na przerwie
        stats.onBreak++;
      } else {
        // Pracuje (nie na przerwie)
        if (!stats.byDepartment[department]) {
          stats.byDepartment[department] = 0;
        }
        stats.byDepartment[department]++;
      }
    }
  }
  
  return stats;
}
/**
 * FUNKCJA TESTOWA - sprawdza czy L4 dzia≈Ça
 */
function testL4Dashboard() {
  console.log('=== TEST L4 W DASHBOARDZIE ===');
  
  try {
    const data = getDashboardData();
    
    console.log('\n--- OG√ìLNY BILANS ---');
    console.log('Zaplanowano:', data.overall.planned);
    console.log('Obecni:', data.overall.present);
    console.log('Nieobecni:', data.overall.absent);
    console.log('Urlop:', data.overall.vacation);
    console.log('L4:', data.overall.l4);  // ‚Üê NOWE!
    console.log('Frekwencja:', data.overall.frekwencja + '%');
    
    console.log('\n--- ZMIANY Z L4 ---');
    Object.keys(data.shifts).forEach(shiftKey => {
      const shift = data.shifts[shiftKey];
      if (shift.started && shift.l4 > 0) {
        console.log(`\nZmiana ${shiftKey}:`);
        console.log(`  L4: ${shift.l4}`);
        console.log(`  Urlop: ${shift.vacation}`);
        console.log(`  Nieobecni: ${shift.absent}`);
      }
    });
    
    console.log('\n=== TEST ZAKO≈ÉCZONY SUKCESEM ===');
    return 'OK';
    
  } catch (error) {
    console.error('B≈ÅƒÑD:', error.toString());
    return 'ERROR: ' + error.toString();
  }
}

/**
 * Pobiera historiƒô nieobecno≈õci
 */
function getAbsenceHistory(days = null) {
  sprawdzUprawnienia();
  
  console.log('=== POBIERANIE HISTORII NIEOBECNO≈öCI ===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  
  // Znajd≈∫ najstarszƒÖ datƒô w logach
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  const logsData = logsSheet.getDataRange().getValues();

  let oldestLogDate = new Date();
  for (let i = 1; i < logsData.length; i++) {
    if (logsData[i][1]) {
      const logDate = new Date(logsData[i][1]);
      logDate.setHours(0, 0, 0, 0);
      if (logDate < oldestLogDate) {
        oldestLogDate = logDate;
      }
    }
  }
  
  // Oblicz zakres dat
  let startDate, endDate;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (days === null) {
  // Brak parametru - od najstarszego logu do dzisiaj (dla log√≥w)
  // Urlopy i L4 bƒôdƒÖ mia≈Çy +30 dni dodane p√≥≈∫niej
  startDate = oldestLogDate;
  endDate = new Date(today);
  
  console.log(`Zakres log√≥w: ${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]}`);
  console.log(`Zakres urlop√≥w/L4: ${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]} + 30 dni`);
  } else {
  // Parametr days - ostatnie X dni OD NAJNOWSZEGO LOGU
  let newestLogDate = oldestLogDate;
  for (let i = 1; i < logsData.length; i++) {
    if (logsData[i][1]) {
      const logDate = new Date(logsData[i][1]);
      logDate.setHours(0, 0, 0, 0);
      if (logDate > newestLogDate) {
        newestLogDate = logDate;
      }
    }
  }
  
  endDate = new Date(newestLogDate);
  startDate = new Date(newestLogDate);
  startDate.setDate(startDate.getDate() - days + 1);
  
  // Nie cofaj siƒô przed najstarszym logiem
  if (startDate < oldestLogDate) {
    startDate = oldestLogDate;
  }
  
  console.log(`Zakres: ostatnie ${days} dni od najnowszego logu (${startDate.toISOString().split('T')[0]} - ${endDate.toISOString().split('T')[0]})`);
}

  const startDateStr = Utilities.formatDate(startDate, 'Europe/Warsaw', 'yyyy-MM-dd');
  const endDateStr = Utilities.formatDate(endDate, 'Europe/Warsaw', 'yyyy-MM-dd');
  
  // Oblicz zakres dla urlop√≥w i L4 (+/-30 dni)
const vacationStartDate = new Date(startDate);
vacationStartDate.setDate(vacationStartDate.getDate() - 30); // -30 dni wstecz

const vacationEndDate = new Date(endDate);
vacationEndDate.setDate(vacationEndDate.getDate() + 30); // +30 dni w przysz≈Ço≈õƒá

const vacationStartDateStr = Utilities.formatDate(vacationStartDate, 'Europe/Warsaw', 'yyyy-MM-dd');
const vacationEndDateStr = Utilities.formatDate(vacationEndDate, 'Europe/Warsaw', 'yyyy-MM-dd');

// Pobierz dane z odpowiednimi zakresami
const vacations = getVacationHistoryRange(vacationStartDateStr, vacationEndDateStr);
console.log(`Znaleziono ${vacations.length} urlop√≥w w zakresie ${vacationStartDateStr} - ${vacationEndDateStr} (¬±30 dni)`);

vacations.forEach(v => {
  console.log(`  - ${v.name}: ${v.dateFrom} - ${v.dateTo}`);
});

const l4List = getL4HistoryRange(vacationStartDateStr, vacationEndDateStr);
console.log(`Znaleziono ${l4List.length} L4 w zakresie ${vacationStartDateStr} - ${vacationEndDateStr} (¬±30 dni)`);

// ‚Üê NOWE: Dni wolne
const dayOffList = getDayOffHistoryRange(vacationStartDateStr, vacationEndDateStr);
console.log(`Znaleziono ${dayOffList.length} dni wolnych w zakresie ${vacationStartDateStr} - ${vacationEndDateStr}`);

// ‚Üê NOWE: Urlopy okoliczno≈õciowe
const occasionalList = getOccasionalLeaveHistoryRange(vacationStartDateStr, vacationEndDateStr);
console.log(`Znaleziono ${occasionalList.length} urlop√≥w okoliczno≈õciowych w zakresie ${vacationStartDateStr} - ${vacationEndDateStr}`);

// Nieobecno≈õci tylko z zakresu log√≥w (bez +30 dni)
const unjustified = getUnjustifiedAbsencesRange(startDateStr, endDateStr);
console.log(`Znaleziono ${unjustified.length} nieobecno≈õci w zakresie ${startDateStr} - ${endDateStr} (tylko logi)`);
  
  // Po≈ÇƒÖcz wszystko w jednƒÖ listƒô
  const allAbsences = [];
  
  // Dodaj urlopy
  vacations.forEach(v => {
    allAbsences.push({
      dateFrom: v.dateFrom,
      dateTo: v.dateTo,
      days: v.days,
      login: v.login,
      name: v.name,
      type: 'vacation',
      typeText: 'üèñÔ∏è Urlop',
      details: v.vacationType,
      status: v.status
    });
  });
  
  // Dodaj L4
  l4List.forEach(l => {
    allAbsences.push({
      dateFrom: l.dateFrom,
      dateTo: l.dateTo,
      days: l.days,
      login: l.login,
      name: l.name,
      type: 'l4',
      typeText: 'üè• L4',
      details: l.l4Type,
      status: l.status
    });
  });
  
  // Dodaj dni wolne
  dayOffList.forEach(d => {
    allAbsences.push({
      dateFrom: d.dateFrom,
      dateTo: d.dateTo,
      days: d.days,
      login: d.login,
      name: d.name,
      type: 'dayoff',
      typeText: 'üìÖ Dzie≈Ñ wolny',
      details: d.dayOffType,
      status: d.status
    });
  });
  
  // Dodaj urlopy okoliczno≈õciowe
  occasionalList.forEach(o => {
    allAbsences.push({
      dateFrom: o.dateFrom,
      dateTo: o.dateTo,
      days: o.days,
      login: o.login,
      name: o.name,
      type: 'occasional',
      typeText: 'üéä Urlop okol.',
      details: o.occasionalType,
      status: o.status
    });
  });
  
  // Dodaj nieusprawiedliwione
  unjustified.forEach(u => {
    allAbsences.push({
      dateFrom: u.date,
      dateTo: u.date,
      days: 0,
      login: u.login,
      name: u.name,
      type: 'unjustified',
      typeText: '‚ùå Nieobecny',
      details: `${u.shift}, ${u.department}`,
      status: '-'
    });
  });
  
  // Sortuj: data malejƒÖco (najnowsze pierwsze)
  allAbsences.sort((a, b) => {
    return b.dateFrom.localeCompare(a.dateFrom);
  });
  
  console.log(`Znaleziono ${allAbsences.length} nieobecno≈õci`);
  
  return {
    absences: allAbsences,
    stats: calculateAbsenceStats(allAbsences, startDateStr, endDateStr)
  };
}

/**
 * Pobiera urlopy z zakresu dat
 */
function getVacationHistoryRange(startDate, endDate) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const vacSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
  const data = vacSheet.getDataRange().getValues();
  
  const vacations = [];
  
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, , dateFrom, dateTo, days, status, type] = data[i];
    
    if (status !== 'Zatwierdzony' || !dateFrom || !dateTo) continue;
    
    const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
    const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Sprawd≈∫ czy urlop nak≈Çada siƒô na zakres dat
    if (from <= endDate && to >= startDate) {
      const today = Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd');
      const isOngoing = today >= from && today <= to;
      const isCompleted = today > to;
      
      // Mapowanie typ√≥w urlop√≥w (dla backward compatibility)
      const typeMapping = {
        'na-zadanie': 'Na ≈ºƒÖdanie',
        'na zadanie': 'Na ≈ºƒÖdanie',
        'planowany': 'Planowany',
        'na-zadanie': 'Na ≈ºƒÖdanie'
      };

      vacations.push({
        login: login,
        name: name,
        dateFrom: from,
        dateTo: to,
        days: days || 1,
        vacationType: typeMapping[type] || type || 'Planowany',
        status: isCompleted ? '‚úÖ Zako≈Ñczony' : (isOngoing ? 'üîÑ Trwa' : 'üîÑ Zaplanowany')
      });
    }
  }
  
  return vacations;
}

/**
 * Pobiera L4 z zakresu dat
 */
function getL4HistoryRange(startDate, endDate) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const l4Sheet = ss.getSheetByName(SHEETS.L4 || 'Zwolnienia_lekarskie');
  
  if (!l4Sheet) return [];
  
  const data = l4Sheet.getDataRange().getValues();
  const l4List = [];
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  for (let i = 1; i < data.length; i++) {
    const [id, login, name, dateFrom, dateTo, days, status, type, note] = data[i];
    
    if (!login || !dateFrom || !dateTo) continue;
    
    const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
    const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Sprawd≈∫ czy L4 nak≈Çada siƒô na zakres dat
    if (from <= endDate && to >= startDate) {
      // Okre≈õl aktualny status na podstawie dat
      const fromDate = new Date(dateFrom);
      fromDate.setHours(0, 0, 0, 0);
      const toDate = new Date(dateTo);
      toDate.setHours(0, 0, 0, 0);
      
      let currentStatus;
      if (today < fromDate) {
        currentStatus = 'üîµ Zaplanowane';
      } else if (today >= fromDate && today <= toDate) {
        currentStatus = 'üîÑ Trwa';
      } else {
        currentStatus = '‚úÖ Zako≈Ñczony';
      }
      
      l4List.push({
        login: login,
        name: name,
        dateFrom: from,
        dateTo: to,
        days: days || 1,
        l4Type: type || 'Choroba',
        status: currentStatus
      });
    }
  }
  
  return l4List;
}

/**
 * Pobiera dni wolne z zakresu dat
 */
function getDayOffHistoryRange(startDate, endDate) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const dayOffSheet = ss.getSheetByName('Dni_wolne');
  
  if (!dayOffSheet) return [];
  
  const data = dayOffSheet.getDataRange().getValues();
  const dayOffList = [];
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data, F=Typ, 
    // G=Godzina_od, H=Godzina_do, I=Powod, J=Status
    const login = data[i][1];
    const name = data[i][2];
    const dayOffDate = data[i][4];
    const type = data[i][5];
    const status = data[i][9];
    
    if (!login || !dayOffDate) continue;
    if (status !== 'Zatwierdzony') continue;
    
    const dateStr = Utilities.formatDate(new Date(dayOffDate), 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Sprawd≈∫ czy data mie≈õci siƒô w zakresie
    if (dateStr >= startDate && dateStr <= endDate) {
      // Okre≈õl aktualny status
      const dateObj = new Date(dayOffDate);
      dateObj.setHours(0, 0, 0, 0);
      
      let currentStatus;
      if (today < dateObj) {
        currentStatus = 'üîµ Zaplanowany';
      } else if (today.getTime() === dateObj.getTime()) {
        currentStatus = 'üîÑ Dzi≈õ';
      } else {
        currentStatus = '‚úÖ Zako≈Ñczony';
      }
      
      dayOffList.push({
        login: login,
        name: name,
        dateFrom: dateStr,
        dateTo: dateStr,
        days: 1,
        dayOffType: type || 'Dzie≈Ñ wolny',
        status: currentStatus
      });
    }
  }
  
  return dayOffList;
}

/**
 * Pobiera urlopy okoliczno≈õciowe z zakresu dat
 */
function getOccasionalLeaveHistoryRange(startDate, endDate) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
  
  if (!occasionalSheet) return [];
  
  const data = occasionalSheet.getDataRange().getValues();
  const occasionalList = [];
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  for (let i = 1; i < data.length; i++) {
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data_od, F=Data_do, 
    // G=Dni, H=Typ_wydarzenia, I=Notatka, J=Status
    const login = data[i][1];
    const name = data[i][2];
    const dateFrom = data[i][4];
    const dateTo = data[i][5];
    const days = data[i][6];
    const type = data[i][7];
    const status = data[i][9];
    
    if (!login || !dateFrom || !dateTo) continue;
    if (status !== 'Zatwierdzony') continue;
    
    const from = Utilities.formatDate(new Date(dateFrom), 'Europe/Warsaw', 'yyyy-MM-dd');
    const to = Utilities.formatDate(new Date(dateTo), 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Sprawd≈∫ czy urlop nak≈Çada siƒô na zakres dat
    if (from <= endDate && to >= startDate) {
      // Okre≈õl aktualny status
      const fromDate = new Date(dateFrom);
      fromDate.setHours(0, 0, 0, 0);
      const toDate = new Date(dateTo);
      toDate.setHours(0, 0, 0, 0);
      
      let currentStatus;
      if (today < fromDate) {
        currentStatus = 'üîµ Zaplanowany';
      } else if (today >= fromDate && today <= toDate) {
        currentStatus = 'üîÑ Trwa';
      } else {
        currentStatus = '‚úÖ Zako≈Ñczony';
      }
      
      occasionalList.push({
        login: login,
        name: name,
        dateFrom: from,
        dateTo: to,
        days: days || 1,
        occasionalType: type || 'Urlop okoliczno≈õciowy',
        status: currentStatus
      });
    }
  }
  
  return occasionalList;
}

/**
 * Pobiera nieusprawiedliwione nieobecno≈õci z zakresu dat
 */
function getUnjustifiedAbsencesRange(startDate, endDate) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const userSheet = ss.getSheetByName(SHEETS.USERS);
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);
  
  // Pobierz wszystkich pracownik√≥w
  const userData = userSheet.getDataRange().getValues();
  const workers = {};
  for (let i = 1; i < userData.length; i++) {
    const login = userData[i][0];
    const name = userData[i][2];
    const dept = userData[i][3];
    const startTime = userData[i][5];
    const endTime = userData[i][6];
    
    if (login && startTime && endTime) {
      workers[login] = {
        name: name,
        dept: dept,
        shift: `${startTime}-${endTime}`
      };
    }
  }
  
  // Pobierz wszystkie logi z zakresu
  const logsData = logsSheet.getDataRange().getValues();
  const loginsByDate = {};
  
  for (let i = 1; i < logsData.length; i++) {
    const date = Utilities.formatDate(new Date(logsData[i][1]), 'Europe/Warsaw', 'yyyy-MM-dd');
    const login = logsData[i][2];
    
    if (date >= startDate && date <= endDate) {
      if (!loginsByDate[date]) loginsByDate[date] = new Set();
      loginsByDate[date].add(login);
    }
  }
  
  // Pobierz urlopy, L4, dni wolne i okoliczno≈õciowe z zakresu
  const vacations = getVacationHistoryRange(startDate, endDate);
  const l4List = getL4HistoryRange(startDate, endDate);
  const dayOffList = getDayOffHistoryRange(startDate, endDate);          // ‚Üê NOWE
  const occasionalList = getOccasionalLeaveHistoryRange(startDate, endDate);  // ‚Üê NOWE
  
  // Dla ka≈ºdego dnia sprawd≈∫ kto by≈Ç nieobecny
  const unjustified = [];
  const currentDate = new Date(startDate);
  const endDateObj = new Date(endDate);
  
  while (currentDate <= endDateObj) {
    const dateStr = Utilities.formatDate(currentDate, 'Europe/Warsaw', 'yyyy-MM-dd');
    const dayOfWeek = currentDate.getDay();
    
    // Pomijamy soboty (6), niedziele (0) i ≈õwiƒôta
    if (dayOfWeek !== 0 && dayOfWeek !== 6 && !isPolishHoliday(currentDate)) {
      const loggedInToday = loginsByDate[dateStr] || new Set();
      
      // Sprawd≈∫ ka≈ºdego pracownika
      Object.keys(workers).forEach(login => {
        const wasPresent = loggedInToday.has(login);
        const hadVacation = vacations.some(v => v.login === login && dateStr >= v.dateFrom && dateStr <= v.dateTo);
        const hadL4 = l4List.some(l => l.login === login && dateStr >= l.dateFrom && dateStr <= l.dateTo);
        const hadDayOff = dayOffList.some(d => d.login === login && dateStr === d.dateFrom);  // ‚Üê NOWE
        const hadOccasional = occasionalList.some(o => o.login === login && dateStr >= o.dateFrom && dateStr <= o.dateTo);  // ‚Üê NOWE
        
        // Je≈õli nie by≈Ço w pracy i nie mia≈Ç ≈ºadnej usprawiedliwionej nieobecno≈õci
        if (!wasPresent && !hadVacation && !hadL4 && !hadDayOff && !hadOccasional) {
          unjustified.push({
            date: dateStr,
            login: login,
            name: workers[login].name,
            shift: workers[login].shift,
            department: workers[login].dept
          });
        }
      });
    }
    
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return unjustified;
}

/**
 * Oblicza statystyki nieobecno≈õci
 */
function calculateAbsenceStats(absences, startDate, endDate) {
  let totalVacationDays = 0;
  let totalL4Days = 0;
  let totalDayOffDays = 0;       // ‚Üê NOWE
  let totalOccasionalDays = 0;   // ‚Üê NOWE
  let totalUnjustifiedDays = 0;
  
  absences.forEach(a => {
    if (a.type === 'vacation') {
      totalVacationDays += a.days;
    } else if (a.type === 'l4') {
      totalL4Days += a.days;
    } else if (a.type === 'dayoff') {         // ‚Üê NOWE
      totalDayOffDays += a.days;
    } else if (a.type === 'occasional') {     // ‚Üê NOWE
      totalOccasionalDays += a.days;
    } else if (a.type === 'unjustified') {
      totalUnjustifiedDays += 1;
    }
  });
  
  return {
    totalVacationDays: totalVacationDays,
    totalL4Days: totalL4Days,
    totalDayOffDays: totalDayOffDays,         // ‚Üê NOWE
    totalOccasionalDays: totalOccasionalDays, // ‚Üê NOWE
    totalOtherDays: totalDayOffDays + totalOccasionalDays,  // ‚Üê ZBIORCZY
    totalUnjustifiedDays: totalUnjustifiedDays,
    periodStart: startDate,
    periodEnd: endDate
  };
}

/**
 * FUNKCJA TESTOWA - historia nieobecno≈õci
 */
function testAbsenceHistory() {
  console.log('=== TEST HISTORII NIEOBECNO≈öCI ===');
  
  try {
    const history = getAbsenceHistory(7); // ostatnie 7 dni
    
    console.log('\n--- STATYSTYKI ---');
    console.log('Dni urlopowe:', history.stats.totalVacationDays);
    console.log('Dni L4:', history.stats.totalL4Days);
    console.log('Dni nieusprawiedliwione:', history.stats.totalUnjustifiedDays);
    
    console.log('\n--- PIERWSZE 5 NIEOBECNO≈öCI ---');
    history.absences.slice(0, 5).forEach(a => {
      console.log(`${a.dateFrom} | ${a.name} | ${a.typeText} | ${a.details}`);
    });
    
    console.log('\n=== TEST ZAKO≈ÉCZONY SUKCESEM ===');
    return 'OK';
    
  } catch (error) {
    console.error('B≈ÅƒÑD:', error.toString());
    return 'ERROR: ' + error.toString();
  }
}

/**
 * TEST - urlopy na dzi≈õ
 */
function testTodayVacations() {
  const today = Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd');
  console.log('Dzisiaj:', today);
  
  const vacations = getVacationHistoryRange(today, today);
  console.log('Znalezione urlopy:', vacations.length);
  
  vacations.forEach(v => {
    console.log(`${v.name}: ${v.dateFrom} - ${v.dateTo}, Typ: ${v.vacationType}`);
  });
  
  return vacations;
}

function exportAbsenceHistoryToExcel(days = null) {
  sprawdzUprawnienia();
  console.log('=== EKSPORT HISTORII NIEOBECNO≈öCI DO EXCEL ===');
  console.log('Parametr dni:', days);
  
  try {
    // 1. Pobierz dane historii
    const history = getAbsenceHistory(days);
    console.log('Pobrano nieobecno≈õci:', history.absences.length);
    
    if (!history || !history.absences || history.absences.length === 0) {
      return {
        success: false,
        message: 'Brak danych do eksportu'
      };
    }
    
    // 2. Utw√≥rz nowy TYMCZASOWY arkusz Excel
    const tempName = 'TEMP_historia_' + new Date().getTime();
    const ss = SpreadsheetApp.create(tempName);
    const sheet = ss.getActiveSheet();
    sheet.setName('Historia nieobecno≈õci');
    
    console.log('Utworzono tymczasowy arkusz:', ss.getId());
    
    // 3. NAG≈Å√ìWKI
    const headers = ['Data', 'Dni', 'Pracownik', 'Typ', 'Szczeg√≥≈Çy', 'Status'];
    const headerRange = sheet.getRange(1, 1, 1, headers.length);
    headerRange.setValues([headers]);
    headerRange.setFontWeight('bold');
    headerRange.setBackground('#667eea');
    headerRange.setFontColor('#ffffff');
    headerRange.setHorizontalAlignment('center');
    
    // 4. DANE
    const data = [];
    history.absences.forEach(absence => {
      const dateRange = absence.dateFrom === absence.dateTo 
        ? absence.dateFrom
        : `${absence.dateFrom} - ${absence.dateTo}`;
      
      const daysText = absence.days > 0 ? absence.days : '-';
      
      // Usu≈Ñ emoji z typu (dla Excela)
      const typeClean = absence.typeText.replace(/[^\w\sƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª-]/g, '').trim();
      
      data.push([
        dateRange,
        daysText,
        absence.name,
        typeClean,
        absence.details,
        absence.status
      ]);
    });
    
    // Wstaw dane
    if (data.length > 0) {
      const dataRange = sheet.getRange(2, 1, data.length, headers.length);
      dataRange.setValues(data);
      
      // 5. FORMATOWANIE WIERSZY (kolory wed≈Çug typu)
      for (let i = 0; i < data.length; i++) {
        const row = i + 2;
        const absence = history.absences[i];
        
        const rowRange = sheet.getRange(row, 1, 1, headers.length);
        
        if (absence.type === 'vacation') {
          rowRange.setBackground('#e1f5fe'); // Niebieski dla urlop√≥w
        } else if (absence.type === 'l4') {
          rowRange.setBackground('#f3e5f5'); // Fioletowy dla L4
        } else if (absence.type === 'unjustified') {
          rowRange.setBackground('#ffebee'); // Czerwony dla nieobecno≈õci
        }
        
        // Wyr√≥≈ºnienie obecnego tygodnia
        const today = new Date();
        const currentWeekStart = getMonday(today);
        const currentWeekEnd = new Date(currentWeekStart);
        currentWeekEnd.setDate(currentWeekEnd.getDate() + 6);
        
        const absenceDate = new Date(absence.dateFrom);
        if (absenceDate >= currentWeekStart && absenceDate <= currentWeekEnd) {
          rowRange.setFontWeight('bold');
        }
      }
    }
    
    // 6. AUTOFILTRY
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    if (lastRow > 1) {
      sheet.getRange(1, 1, lastRow, lastCol).createFilter();
    }
    
    // 7. SZEROKO≈öCI KOLUMN
    sheet.setColumnWidth(1, 180); // Data
    sheet.setColumnWidth(2, 60);  // Dni
    sheet.setColumnWidth(3, 150); // Pracownik
    sheet.setColumnWidth(4, 100); // Typ
    sheet.setColumnWidth(5, 200); // Szczeg√≥≈Çy
    sheet.setColumnWidth(6, 120); // Status
    
    // 8. PODSUMOWANIE NA KO≈ÉCU
    const summaryRow = lastRow + 2;
    sheet.getRange(summaryRow, 1).setValue('PODSUMOWANIE:').setFontWeight('bold');
    sheet.getRange(summaryRow, 1, 1, lastCol).setBackground('#f8f9fa');
    
    sheet.getRange(summaryRow + 1, 1).setValue('Dni urlopowe:');
    sheet.getRange(summaryRow + 1, 2).setValue(history.stats.totalVacationDays).setFontWeight('bold');
    
    sheet.getRange(summaryRow + 2, 1).setValue('Dni L4:');
    sheet.getRange(summaryRow + 2, 2).setValue(history.stats.totalL4Days).setFontWeight('bold');
    
    sheet.getRange(summaryRow + 3, 1).setValue('Dni nieusprawiedliwione:');
    sheet.getRange(summaryRow + 3, 2).setValue(history.stats.totalUnjustifiedDays).setFontWeight('bold');
    
    const startDate = new Date(history.stats.periodStart);
    const endDate = new Date(history.stats.periodEnd);
    const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
    
    sheet.getRange(summaryRow + 5, 1).setValue(`Okres: ${history.stats.periodStart} - ${history.stats.periodEnd} (${daysDiff} dni)`);
    
    // 9. Zamro≈∫ pierwszy wiersz
    sheet.setFrozenRows(1);
    
    /// 10. ‚úÖ OSTATECZNA NAPRAWA - EKSPORT PRZEZ URL
    SpreadsheetApp.flush();
    Utilities.sleep(2000); // D≈Çu≈ºsze oczekiwanie

    const today_str = Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd');
    const fileName = `historia_nieobecnosci_${today_str}.xlsx`;

    // U≈ºyj eksportu przez URL z Google Drive API
    const url = `https://docs.google.com/spreadsheets/d/${ss.getId()}/export?format=xlsx`;
    const token = ScriptApp.getOAuthToken();

    const response = UrlFetchApp.fetch(url, {
      headers: {
        'Authorization': 'Bearer ' + token
      }
    });

    const excelBlob = response.getBlob().setName(fileName);
    const excelFile = DriveApp.createFile(excelBlob);
    excelFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    console.log('Plik Excel zapisany:', excelFile.getId());
    
    // Usu≈Ñ tymczasowy arkusz Google Sheets
    DriveApp.getFileById(ss.getId()).setTrashed(true);
    
    console.log('Eksport zako≈Ñczony:', fileName);
    
    return {
      success: true,
      fileName: fileName,
      fileId: excelFile.getId(),
      downloadUrl: excelFile.getDownloadUrl(),
      message: 'Eksport zako≈Ñczony pomy≈õlnie'
    };
    
  } catch (error) {
    console.error('B≈ÇƒÖd eksportu do Excel:', error);
    console.error('Stack trace:', error.stack);
    return {
      success: false,
      message: 'B≈ÇƒÖd eksportu: ' + error.toString()
    };
  }
}

function exportAbsenceHistoryToPDF(days = null) {
  sprawdzUprawnienia();
  console.log('=== EKSPORT HISTORII NIEOBECNO≈öCI DO PDF ===');
  console.log('Parametr dni:', days);
  
  try {
    // 1. Pobierz dane historii
    const history = getAbsenceHistory(days);
    console.log('Pobrano nieobecno≈õci:', history.absences.length);
    
    if (!history || !history.absences || history.absences.length === 0) {
      return {
        success: false,
        message: 'Brak danych do eksportu'
      };
    }
    
    // 2. Najpierw utw√≥rz arkusz
    const tempName = 'TEMP_pdf_' + new Date().getTime();
    const ss = SpreadsheetApp.create(tempName);
    const sheet = ss.getActiveSheet();
    sheet.setName('Historia nieobecno≈õci');
    
    console.log('Utworzono tymczasowy arkusz dla PDF:', ss.getId());
    
    // 3. TYTU≈Å DOKUMENTU (na g√≥rze)
    const headers = ['Data', 'Dni', 'Pracownik', 'Typ', 'Szczeg√≥≈Çy', 'Status'];
    
    sheet.getRange(1, 1, 1, headers.length).merge();
    sheet.getRange(1, 1).setValue('HISTORIA NIEOBECNO≈öCI')
      .setFontSize(16)
      .setFontWeight('bold')
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle')
      .setBackground('#667eea')
      .setFontColor('#ffffff');
    sheet.setRowHeight(1, 40);
    
    // 4. NAG≈Å√ìWKI
    const headerRange = sheet.getRange(2, 1, 1, headers.length);
    headerRange.setValues([headers]);
    headerRange.setFontWeight('bold');
    headerRange.setBackground('#667eea');
    headerRange.setFontColor('#ffffff');
    headerRange.setHorizontalAlignment('center');
    headerRange.setVerticalAlignment('middle');
    
    // 5. DANE
    const data = [];
    history.absences.forEach(absence => {
      const dateRange = absence.dateFrom === absence.dateTo 
        ? absence.dateFrom
        : `${absence.dateFrom} - ${absence.dateTo}`;
      
      const daysText = absence.days > 0 ? absence.days : '-';
      
      // Usu≈Ñ emoji z typu
      const typeClean = absence.typeText.replace(/[^\w\sƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª-]/g, '').trim();
      
      data.push([
        dateRange,
        daysText,
        absence.name,
        typeClean,
        absence.details,
        absence.status
      ]);
    });
    
    // Wstaw dane
    if (data.length > 0) {
      const dataRange = sheet.getRange(3, 1, data.length, headers.length);
      dataRange.setValues(data);
      dataRange.setVerticalAlignment('middle');
      dataRange.setWrap(true);
      
      // 6. FORMATOWANIE WIERSZY
      for (let i = 0; i < data.length; i++) {
        const row = i + 3; // +3 bo tytu≈Ç + nag≈Ç√≥wki
        const absence = history.absences[i];
        
        const rowRange = sheet.getRange(row, 1, 1, headers.length);
        
        if (absence.type === 'vacation') {
          rowRange.setBackground('#e1f5fe');
        } else if (absence.type === 'l4') {
          rowRange.setBackground('#f3e5f5');
        } else if (absence.type === 'unjustified') {
          rowRange.setBackground('#ffebee');
        }
        
        // Wyr√≥≈ºnienie obecnego tygodnia
        const today = new Date();
        const currentWeekStart = getMonday(today);
        const currentWeekEnd = new Date(currentWeekStart);
        currentWeekEnd.setDate(currentWeekEnd.getDate() + 6);
        
        const absenceDate = new Date(absence.dateFrom);
        if (absenceDate >= currentWeekStart && absenceDate <= currentWeekEnd) {
          rowRange.setFontWeight('bold');
        }
      }
    }
    
    // 7. SZEROKO≈öCI KOLUMN (dla PDF - mniejsze)
    sheet.setColumnWidth(1, 140);
    sheet.setColumnWidth(2, 50);
    sheet.setColumnWidth(3, 120);
    sheet.setColumnWidth(4, 80);
    sheet.setColumnWidth(5, 150);
    sheet.setColumnWidth(6, 100);
    
    // 8. PODSUMOWANIE
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    const summaryRow = lastRow + 2;
    
    sheet.getRange(summaryRow, 1).setValue('PODSUMOWANIE:').setFontWeight('bold').setFontSize(12);
    sheet.getRange(summaryRow, 1, 1, lastCol).setBackground('#f8f9fa');
    
    sheet.getRange(summaryRow + 1, 1).setValue('Dni urlopowe:');
    sheet.getRange(summaryRow + 1, 2).setValue(history.stats.totalVacationDays).setFontWeight('bold');
    
    sheet.getRange(summaryRow + 2, 1).setValue('Dni L4:');
    sheet.getRange(summaryRow + 2, 2).setValue(history.stats.totalL4Days).setFontWeight('bold');
    
    sheet.getRange(summaryRow + 3, 1).setValue('Dni nieusprawiedliwione:');
    sheet.getRange(summaryRow + 3, 2).setValue(history.stats.totalUnjustifiedDays).setFontWeight('bold');
    
    const startDate = new Date(history.stats.periodStart);
    const endDate = new Date(history.stats.periodEnd);
    const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
    
    sheet.getRange(summaryRow + 5, 1, 1, lastCol).merge();
    sheet.getRange(summaryRow + 5, 1).setValue(`Okres: ${history.stats.periodStart} - ${history.stats.periodEnd} (${daysDiff} dni)`);
    
    // 9. Zamro≈∫ nag≈Ç√≥wki
    sheet.setFrozenRows(2);
    
    // 10. Ustaw orientacjƒô
    ss.setSpreadsheetTimeZone('Europe/Warsaw');
    
    // 11. ‚ö†Ô∏è FLUSH - WA≈ªNE!
    SpreadsheetApp.flush();
    Utilities.sleep(2000); // Poczekaj 2 sekundy na zapisanie
    
    // 12. Konwertuj na PDF
    const file = DriveApp.getFileById(ss.getId());
    const pdfBlob = file.getAs('application/pdf');
    
    const today_str = Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd');
    const fileName = `historia_nieobecnosci_${today_str}.pdf`;
    pdfBlob.setName(fileName);
    
    console.log('Konwersja na PDF zako≈Ñczona');
    
    // Zapisz PDF w Drive
    const pdfFile = DriveApp.createFile(pdfBlob);
    pdfFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    // Pobierz link do folderu (gdzie zapisano PDF)
    const parentFolder = pdfFile.getParents().next();
    const folderUrl = parentFolder.getUrl();
    
    console.log('Plik PDF zapisany:', pdfFile.getId());
    console.log('Folder:', folderUrl);
    
    // Usu≈Ñ tymczasowy arkusz
    DriveApp.getFileById(ss.getId()).setTrashed(true);
    
    console.log('Eksport PDF zako≈Ñczony:', fileName);
    
    return {
      success: true,
      fileName: fileName,
      fileId: pdfFile.getId(),
      downloadUrl: pdfFile.getDownloadUrl(),
      viewUrl: pdfFile.getUrl(), // ‚úÖ Link do podglƒÖdu
      folderUrl: folderUrl, // ‚úÖ Link do folderu
      message: 'Eksport do PDF zako≈Ñczony pomy≈õlnie'
    };
    
  } catch (error) {
    console.error('B≈ÇƒÖd eksportu do PDF:', error);
    console.error('Stack trace:', error.stack);
    return {
      success: false,
      message: 'B≈ÇƒÖd eksportu PDF: ' + error.toString()
    };
  }
}

/**
 * Pomocnicza funkcja - zwraca poniedzia≈Çek danego tygodnia
 * (je≈õli jeszcze nie istnieje w Code.gs)
 */
function getMonday(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  return new Date(d.setDate(diff));
}

/**
 * Rejestruje L4 w arkuszu Zwolnienia_lekarskie
 */
function registerL4(employeeLogin, startDate, endDate, l4Type, note) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const l4Sheet = ss.getSheetByName('Zwolnienia_lekarskie');
    
    if (!l4Sheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Zwolnienia_lekarskie'
      };
    }
    
    // Pobierz dane pracownika
    const pracownicySheet = ss.getSheetByName('Pracownicy');
    if (!pracownicySheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Pracownicy'
      };
    }
    
    const pracownicyData = pracownicySheet.getDataRange().getValues();
    const pracownicyHeaders = pracownicyData[0];
    const loginIndex = pracownicyHeaders.indexOf('login');
    const imieNazwiskoIndex = pracownicyHeaders.indexOf('imie_nazwisko');
    
    // Znajd≈∫ imiƒô i nazwisko pracownika
    let employeeName = employeeLogin;
    for (let i = 1; i < pracownicyData.length; i++) {
      if (pracownicyData[i][loginIndex] === employeeLogin) {
        employeeName = pracownicyData[i][imieNazwiskoIndex] || employeeLogin;
        break;
      }
    }
    
    Logger.log('Employee Login: ' + employeeLogin);
    Logger.log('Employee Name: ' + employeeName);
    
    // Oblicz dni KALENDARZOWE (w≈ÇƒÖcznie z weekendami)
    const start = new Date(startDate);
    const end = new Date(endDate);
    const diffTime = Math.abs(end - start);
    const calendarDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
    
    // Okre≈õl status na podstawie dat
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const startDateObj = new Date(startDate);
    startDateObj.setHours(0, 0, 0, 0);
    const endDateObj = new Date(endDate);
    endDateObj.setHours(0, 0, 0, 0);
    
    let status = 'Zaplanowane';
    if (today >= startDateObj && today <= endDateObj) {
      status = 'Trwa';
    } else if (today > endDateObj) {
      status = 'Zako≈Ñczone';
    }
    
    // Pobierz ostatnie ID
    const lastRow = l4Sheet.getLastRow();
    let newId = 1;
    if (lastRow > 1) {
      const lastId = l4Sheet.getRange(lastRow, 1).getValue();
      newId = (parseInt(lastId) || 0) + 1;
    }
    
    // Dodaj wiersz (zgodnie z kolejno≈õciƒÖ kolumn w arkuszu)
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_od, E=Data_do, F=Dni, G=Status, H=Typ_L4, I=Notatka
    const newRow = [
      newId,                    // A - ID
      employeeLogin,            // B - Login
      employeeName,             // C - Imie_Nazwisko
      startDate,                // D - Data_od
      endDate,                  // E - Data_do
      calendarDays,             // F - Dni
      status,                   // G - Status
      l4Type,                   // H - Typ_L4
      note || ''                // I - Notatka
    ];
    
    l4Sheet.appendRow(newRow);
    
    Logger.log('Zarejestrowano L4 dla: ' + employeeName + ' (' + employeeLogin + ')');
    
    return {
      success: true,
      message: `Zarejestrowano L4 dla ${employeeName} (${calendarDays} dni)`
    };
    
  } catch (error) {
    Logger.log('B≈ÅƒÑD registerL4: ' + error.toString());
    return {
      success: false,
      message: 'B≈ÇƒÖd rejestracji: ' + error.toString()
    };
  }
}

/**
 * Pobiera listƒô aktywnych L4
 */
function getActiveL4List() {
  sprawdzUprawnienia();
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const l4Sheet = ss.getSheetByName('Zwolnienia_lekarskie');
  
  if (!l4Sheet) {
    return { l4List: [] };
  }
  
  const data = l4Sheet.getDataRange().getValues();
  const l4List = [];
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  for (let i = 1; i < data.length; i++) {
    const status = data[i][6]; // Kolumna G - Status
    
    // Poka≈º wszystkie L4 kt√≥re nie sƒÖ zako≈Ñczone (Aktywne lub Zaplanowane lub Trwa)
    if (status !== 'Zako≈Ñczone') {
      const dateFrom = new Date(data[i][3]);
      dateFrom.setHours(0, 0, 0, 0);
      const dateTo = new Date(data[i][4]);
      dateTo.setHours(0, 0, 0, 0);
      
      // Okre≈õl aktualny status na podstawie dat
      let currentStatus = 'Zaplanowane';
      let isActive = false;
      
      if (today >= dateFrom && today <= dateTo) {
        currentStatus = 'Trwa';
        isActive = true;
      } else if (today > dateTo) {
        currentStatus = 'Zako≈Ñczone';
        isActive = false;
      } else {
        currentStatus = 'Zaplanowane';
        isActive = false;
      }
      
      l4List.push({
        id: data[i][0],
        login: data[i][1],
        name: data[i][2],
        dateFrom: Utilities.formatDate(dateFrom, 'Europe/Warsaw', 'yyyy-MM-dd'),
        dateTo: Utilities.formatDate(dateTo, 'Europe/Warsaw', 'yyyy-MM-dd'),
        days: data[i][5],
        type: data[i][7],
        note: data[i][8] || '',
        isActive: isActive,
        status: currentStatus  // Dodaj status do zwracanych danych
      });
    }
  }
  
  return { l4List: l4List };
}

/**
 * Ko≈Ñczy L4 wcze≈õniej
 */
function endL4(l4Id, endDate) {
  sprawdzUprawnienia();
  console.log('=== ZAKO≈ÉCZENIE L4 ===', l4Id, endDate);
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const l4Sheet = ss.getSheetByName('Zwolnienia_lekarskie');
  
  const data = l4Sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === l4Id) {
      // Zaktualizuj datƒô ko≈ÑcowƒÖ
      const newEndDate = new Date(endDate);
      const startDate = new Date(data[i][3]);
      const newDays = Math.ceil((newEndDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
      
      l4Sheet.getRange(i + 1, 5).setValue(endDate); // Data_do
      l4Sheet.getRange(i + 1, 6).setValue(newDays); // Dni
      l4Sheet.getRange(i + 1, 7).setValue('Zako≈Ñczone'); // Status
      
      return {
        success: true,
        message: 'L4 zako≈Ñczone wcze≈õniej'
      };
    }
  }
  
  throw new Error('Nie znaleziono L4');
}

/**
 * Usuwa L4
 */
function deleteL4(l4Id) {
  sprawdzUprawnienia();
  console.log('=== USUWANIE L4 ===', l4Id);
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const l4Sheet = ss.getSheetByName('Zwolnienia_lekarskie');
  
  const data = l4Sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === l4Id) {
      l4Sheet.deleteRow(i + 1);
      
      return {
        success: true,
        message: 'L4 usuniƒôte'
      };
    }
  }
  
  throw new Error('Nie znaleziono L4');
}

// ===== MODU≈Å ZG≈ÅOSZE≈É - TICKETY =====

/**
 * Rejestruje zg≈Çoszenie w arkuszu Zg≈Çoszenia
 */
function submitTicket(login, name, category, title, description, location, priority) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName(SHEETS.TICKETS || 'Zg≈Çoszenia');
    
    if (!ticketSheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Zg≈Çoszenia'
      };
    }
    
    // Pobierz ostatnie ID
    const lastRow = ticketSheet.getLastRow();
    let newId = 1;
    if (lastRow > 1) {
      const lastId = ticketSheet.getRange(lastRow, 1).getValue();
      newId = (parseInt(lastId) || 0) + 1;
    }
    
    // Przygotuj ikonƒô kategorii
    const categoryIcons = {
      'pomys≈Ç': 'üí°',
      'problem': '‚ö†Ô∏è',
      'usterka': 'üîß',
      'pilne': 'üÜò'
    };
    
    const categoryText = categoryIcons[category] + ' ' + category.charAt(0).toUpperCase() + category.slice(1);
    
    // Aktualna data i czas
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    const timeStr = Utilities.formatDate(now, 'Europe/Warsaw', 'HH:mm:ss');
    
    // Dodaj wiersz (zgodnie z kolejno≈õciƒÖ kolumn w arkuszu)
    // A=ID, B=Data_zg≈Çoszenia, C=Czas, D=Login, E=Imiƒô_nazwisko, 
    // F=Kategoria, G=Tytu≈Ç, H=Opis, I=Lokalizacja, J=Priorytet, 
    // K=Status, L=Data_rozpoczƒôcia, M=Komentarz_managera
    const newRow = [
      newId,                    // A - ID
      dateStr,                  // B - Data_zg≈Çoszenia
      timeStr,                  // C - Czas
      login,                    // D - Login
      name,                     // E - Imiƒô_nazwisko
      categoryText,             // F - Kategoria
      title,                    // G - Tytu≈Ç
      description,              // H - Opis
      location || '-',          // I - Lokalizacja
      priority,                 // J - Priorytet
      'üÜï Nowe',                // K - Status
      '',                       // L - Data_rozpoczƒôcia
      ''                        // M - Komentarz_managera
    ];
    
    ticketSheet.appendRow(newRow);
    
    Logger.log('Zarejestrowano ticket #' + newId + ' od: ' + name + ' (' + login + ')');
    
    // Je≈õli KRYTYCZNE - mo≈ºna dodaƒá powiadomienie email (opcjonalnie)
    if (priority === 'KRYTYCZNY') {
      Logger.log('‚ö†Ô∏è UWAGA: Zg≈Çoszenie KRYTYCZNE! Ticket #' + newId);
      // TODO: Wys≈Çaƒá email do managera
    }
    
    return {
      success: true,
      message: `Zg≈Çoszenie #${newId} zosta≈Ço zarejestrowane. Dziƒôkujemy!`
    };
    
  } catch (error) {
    Logger.log('B≈ÅƒÑD submitTicket: ' + error.toString());
    return {
      success: false,
      message: 'B≈ÇƒÖd rejestracji: ' + error.toString()
    };
  }
}

// ===== SYSTEM LOGOWANIA =====
function authenticateUser(login, password) {
  // Hardcoded credentials
  if (login === "dbklogistics" && password === "12345") {
    return {
      success: true,
      message: "Zalogowano pomy≈õlnie!",
      isManager: false
    };
  } else if (login === "jerzyd" && password === "12345") {
    return {
      success: true,
      message: "Zalogowano jako kierownik!",
      isManager: true
    };
  } else {
    return {
      success: false,
      message: "‚ùå Nieprawid≈Çowy login lub has≈Ço!"
    };
  }
}

/**
 * Pobiera liczbƒô otwartych ticket√≥w (status OTWARTY)
 */
function getOpenTicketsCount() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      Logger.log('‚ö†Ô∏è Brak arkusza Zg≈Çoszenia');
      return 0;
    }
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) return 0;
    
    const statusColumn = ticketSheet.getRange(2, 11, lastRow - 1, 1).getValues();
    
    let count = 0;
    statusColumn.forEach(row => {
      const status = String(row[0]); // Konwertuj na string
      
      // Sprawd≈∫ czy status ZAWIERA s≈Çowo "Nowe"
      if (status.includes('Nowe')) {
        count++;
      }
    });
    
    Logger.log('‚úÖ Liczba zg≈Çosze≈Ñ ze statusem Nowe: ' + count);
    return count;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getOpenTicketsCount: ' + error.message);
    return 0;
  }
}

function testGetOpenTickets() {
  const result = getOpenTicketsCount();
  Logger.log('üéØ WYNIK FUNKCJI: ' + result);
}

/**
 * Pobiera liczbƒô nieodczytanych odpowiedzi dla pracownika
 * @param {string} login - login pracownika
 * @return {number} liczba nieodczytanych odpowiedzi
 */
function getUnreadTicketRepliesCount(login) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      Logger.log('‚ö†Ô∏è Brak arkusza Zg≈Çoszenia');
      return 0;
    }
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) return 0;
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 15).getValues(); // Pobierz kolumny A-O
    
    let count = 0;
    data.forEach(row => {
      const ticketLogin = row[3]; // Kolumna D - Login
      const status = String(row[10]); // Kolumna K - Status
      const dataOdpowiedzi = row[13]; // Kolumna N - Data_odpowiedzi
      const odczytane = row[14]; // Kolumna O - Odczytane_przez_pracownika
      
      // Zlicz tickety gdzie:
      // 1. Login zg≈ÇaszajƒÖcego = login parametru
      // 2. Kierownik odpowiedzia≈Ç (Data_odpowiedzi nie jest pusta)
      // 3. Pracownik NIE przeczyta≈Ç (Odczytane_przez_pracownika != TRUE)
      if (ticketLogin === login && dataOdpowiedzi && odczytane !== true) {
        count++;
      }
    });
    
    Logger.log(`‚úÖ Pracownik ${login} ma ${count} nieodczytanych odpowiedzi`);
    return count;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getUnreadTicketRepliesCount: ' + error.message);
    return 0;
  }
}

/**
 * Sprawdza czy sƒÖ krytyczne tickety o statusie "Nowe"
 * @return {number} liczba krytycznych ticket√≥w
 */
function getCriticalTicketsCount() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) return 0;
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) return 0;
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 11).getValues(); // Kolumny A-K
    
    let count = 0;
    data.forEach(row => {
      const priorytet = row[9]; // Kolumna J - Priorytet
      const status = String(row[10]); // Kolumna K - Status
      
      // Zlicz tickety KRYTYCZNE + status Nowe
      if (priorytet === 'KRYTYCZNY' && status.includes('Nowe')) {
        count++;
      }
    });
    
    Logger.log(`üî¥ Liczba krytycznych ticket√≥w: ${count}`);
    return count;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getCriticalTicketsCount: ' + error.message);
    return 0;
  }
}

/**
 * Pobiera szczeg√≥≈Çy krytycznych ticket√≥w o statusie "Nowe"
 * @return {Array} tablica obiekt√≥w z krytycznymi ticketami
 */
function getCriticalTickets() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) return [];
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) return [];
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 11).getValues();
    
    const criticalTickets = [];
    
    data.forEach((row, index) => {
      const id = row[0];
      const date = row[1];
      const login = row[3];
      const name = row[4];
      const category = row[5];
      const title = row[6];
      const location = row[8];
      const priorytet = row[9];
      const status = String(row[10]);
      
      if (priorytet === 'KRYTYCZNY' && status.includes('Nowe')) {
        criticalTickets.push({
          id: id,
          date: Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm'),
          login: login,
          name: name,
          category: category,
          title: title,
          location: location,
          priority: priorytet,
          status: status
        });
      }
    });
    
    Logger.log('üî¥ Pobrano krytyczne tickety:', criticalTickets.length);
    return criticalTickets;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getCriticalTickets: ' + error.message);
    return [];
  }
}

/**
 * Pobiera wszystkie zg≈Çoszenia z opcjonalnym filtrem statusu
 * @param {string} filterStatus - opcjonalny filtr: 'Nowe', 'W trakcie', 'Zamkniƒôte', 'Odrzucone', 'all'
 * @return {Array} tablica obiekt√≥w ze zg≈Çoszeniami
 */
function getAllTickets(filterStatus) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      Logger.log('‚ö†Ô∏è Brak arkusza Zg≈Çoszenia');
      return [];
    }
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) {
      Logger.log('‚ö†Ô∏è Brak zg≈Çosze≈Ñ w arkuszu');
      return [];
    }
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 15).getValues();
    
    const tickets = [];
    
    data.forEach((row, index) => {
      const status = String(row[10] || '').replace('üîµ ', '').replace('üü° ', '').replace('üü¢ ', '').replace('üî¥ ', '').trim();
      
      // Filtruj po statusie je≈õli podano
      if (filterStatus && filterStatus !== 'all') {
        if (!status.includes(filterStatus)) {
          return;
        }
      }
      
      tickets.push({
        id: row[0] || 0,
        dateSubmitted: row[1] ? String(row[1]) : '',
        time: row[2] ? String(row[2]) : '',
        login: row[3] || '',
        name: row[4] || '',
        category: row[5] || '',
        title: row[6] || '',
        description: row[7] || '',
        location: row[8] || 'Nie podano',
        priority: row[9] || '',
        status: status,
        dateResponse: row[11] ? String(row[11]) : '',
        managerComment: row[12] || '',
        dateStarted: row[13] ? String(row[13]) : '',
        readByEmployee: row[14] === true,
        rowIndex: index + 2
      });
    });
    
    Logger.log('‚úÖ Pobrano ' + tickets.length + ' zg≈Çosze≈Ñ');
    return tickets;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getAllTickets: ' + error.message);
    return [];
  }
}

/**
 * Zmienia status zg≈Çoszenia i dodaje komentarz kierownika
 * @param {number} ticketId - ID zg≈Çoszenia
 * @param {string} newStatus - nowy status: 'W trakcie', 'Zamkniƒôte', 'Odrzucone'
 * @param {string} managerComment - komentarz kierownika
 * @return {Object} wynik operacji
 */
function updateTicketStatus(ticketId, newStatus, managerComment) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      return { success: false, message: 'Brak arkusza Zg≈Çoszenia' };
    }
    
    // Znajd≈∫ wiersz z tym ID
    const lastRow = ticketSheet.getLastRow();
    const idColumn = ticketSheet.getRange(2, 1, lastRow - 1, 1).getValues(); // Kolumna A (ID)
    
    let targetRow = -1;
    for (let i = 0; i < idColumn.length; i++) {
      if (idColumn[i][0] === ticketId) {
        targetRow = i + 2; // +2 bo: indeks 0 = wiersz 2
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, message: 'Nie znaleziono zg≈Çoszenia #' + ticketId };
    }
    
    const now = new Date();
    
    // Przygotuj emoji dla statusu
    let statusEmoji = '';
    if (newStatus === 'W trakcie') statusEmoji = 'üü° ';
    else if (newStatus === 'Zamkniƒôte') statusEmoji = 'üü¢ ';
    else if (newStatus === 'Odrzucone') statusEmoji = 'üî¥ ';
    
    // Aktualizuj kolumny
    ticketSheet.getRange(targetRow, 11).setValue(statusEmoji + newStatus); // Kolumna K - Status
    ticketSheet.getRange(targetRow, 12).setValue(now); // Kolumna L - Data_rozpoczƒôcia
    ticketSheet.getRange(targetRow, 13).setValue(managerComment); // Kolumna M - Komentarz_managera
    
    // Je≈õli status to "Zamkniƒôte" lub "Odrzucone" - ustaw datƒô odpowiedzi
    if (newStatus === 'Zamkniƒôte' || newStatus === 'Odrzucone') {
      ticketSheet.getRange(targetRow, 14).setValue(now); // Kolumna N - Data_odpowiedzi
      ticketSheet.getRange(targetRow, 15).setValue(false); // Kolumna O - Odczytane = FALSE
    }
    
    Logger.log(`‚úÖ Zaktualizowano ticket #${ticketId} na status: ${newStatus}`);
    
    return { 
      success: true, 
      message: `Zg≈Çoszenie #${ticketId} - status zmieniony na: ${newStatus}` 
    };
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd updateTicketStatus: ' + error.message);
    return { success: false, message: 'B≈ÇƒÖd aktualizacji: ' + error.message };
  }
}

/**
 * Pobiera zg≈Çoszenia konkretnego pracownika
 * @param {string} userLogin - login pracownika
 * @return {Array} tablica zg≈Çosze≈Ñ pracownika
 */
function getMyTickets(userLogin) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      Logger.log('‚ö†Ô∏è Brak arkusza Zg≈Çoszenia');
      return [];
    }
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) {
      Logger.log('‚ö†Ô∏è Brak zg≈Çosze≈Ñ w arkuszu');
      return [];
    }
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 15).getValues();
    
    const tickets = [];
    
    data.forEach((row, index) => {
      const login = row[3];
      
      // Filtruj tylko zg≈Çoszenia tego pracownika
      if (login !== userLogin) {
        return;
      }
      
      const id = row[0];
      const dateSubmitted = row[1];
      const time = row[2];
      const name = row[4];
      const category = row[5];
      const title = row[6];
      const description = row[7];
      const location = row[8];
      const priority = row[9];
      const status = String(row[10] || '').replace('üîµ ', '').replace('üü° ', '').replace('üü¢ ', '').replace('üî¥ ', '').trim();
      const dateResponse = row[11];
      const managerComment = row[12];
      const dateStarted = row[13];
      const readByEmployee = row[14];
      
      tickets.push({
        id: id,
        dateSubmitted: dateSubmitted ? String(dateSubmitted) : '',
        time: time ? String(time) : '',
        login: login,
        name: name,
        category: category,
        title: title,
        description: description,
        location: location || 'Nie podano',
        priority: priority,
        status: status,
        dateResponse: dateResponse ? String(dateResponse) : '',
        managerComment: managerComment || '',
        dateStarted: dateStarted ? String(dateStarted) : '',
        readByEmployee: readByEmployee === true || readByEmployee === 'TRUE',
        rowIndex: index + 2
      });
    });
    
    // Sortuj: najnowsze pierwsze (po ID malejƒÖco)
    tickets.sort((a, b) => b.id - a.id);
    
    Logger.log('‚úÖ Pobrano ' + tickets.length + ' zg≈Çosze≈Ñ dla: ' + userLogin);
    return tickets;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getMyTickets: ' + error.message);
    return [];
  }
}

/**
 * Oznacza zg≈Çoszenie jako przeczytane przez pracownika
 * @param {number} ticketId - ID zg≈Çoszenia
 * @return {Object} wynik operacji
 */
function markTicketAsReadByEmployee(ticketId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      return { success: false, message: 'Brak arkusza Zg≈Çoszenia' };
    }
    
    // Znajd≈∫ wiersz ze zg≈Çoszeniem
    const data = ticketSheet.getDataRange().getValues();
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === ticketId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, message: 'Nie znaleziono zg≈Çoszenia #' + ticketId };
    }
    
    // Kolumna O (15) - Odczytane przez pracownika
    ticketSheet.getRange(rowIndex, 15).setValue(true);
    
    Logger.log('‚úÖ Zg≈Çoszenie #' + ticketId + ' oznaczone jako przeczytane');
    
    return { 
      success: true, 
      message: 'Zg≈Çoszenie oznaczone jako przeczytane'
    };
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd markTicketAsReadByEmployee: ' + error.message);
    return { 
      success: false, 
      message: 'B≈ÇƒÖd: ' + error.message 
    };
  }
}

/**
 * Pobiera liczbƒô nieodczytanych odpowiedzi dla pracownika
 * @param {string} userLogin - login pracownika
 * @return {number} liczba nieodczytanych odpowiedzi
 */
function getUnreadTicketsCount(userLogin) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ticketSheet = ss.getSheetByName('Zg≈Çoszenia');
    
    if (!ticketSheet) {
      Logger.log('‚ö†Ô∏è Brak arkusza Zg≈Çoszenia');
      return 0;
    }
    
    const lastRow = ticketSheet.getLastRow();
    if (lastRow <= 1) {
      return 0;
    }
    
    const data = ticketSheet.getRange(2, 1, lastRow - 1, 15).getValues();
    
    let unreadCount = 0;
    
    data.forEach((row) => {
      const login = row[3];
      const status = String(row[10] || '').replace('üîµ ', '').replace('üü° ', '').replace('üü¢ ', '').replace('üî¥ ', '').trim();
      const readByEmployee = row[14];
      
      // ‚úÖ Zlicz zg≈Çoszenia tego pracownika kt√≥re:
      // 1. MajƒÖ status W trakcie, Zamkniƒôte lub Odrzucone (kierownik podjƒÖ≈Ç akcjƒô)
      // 2. Nie sƒÖ przeczytane przez pracownika
      if (login === userLogin && 
          readByEmployee !== true && 
          readByEmployee !== 'TRUE') {
        
        // Je≈õli status to W trakcie, Zamkniƒôte lub Odrzucone - liczy siƒô jako odpowied≈∫
        if (status === 'W trakcie' || status === 'Zamkniƒôte' || status === 'Odrzucone') {
          unreadCount++;
        }
      }
    });
    
    Logger.log('‚úÖ Nieodczytane odpowiedzi dla ' + userLogin + ': ' + unreadCount);
    return unreadCount;
    
  } catch (error) {
    Logger.log('‚ùå B≈ÇƒÖd getUnreadTicketsCount: ' + error.message);
    return 0;
  }
}

function testGetAllTicketsNEW() {
  Logger.log('üß™ TEST - wywo≈Çujƒô getAllTickets("all")');
  const result = getAllTickets('all');
  
  Logger.log('üìä Typ wyniku: ' + typeof result);
  Logger.log('üìä Czy array? ' + Array.isArray(result));
  Logger.log('üìä Liczba element√≥w: ' + (result ? result.length : 'NULL'));
  
  if (result && result.length > 0) {
    Logger.log('üìã Pierwszy element: ' + JSON.stringify(result[0]));
  }
  
  return result;
}

// ===== MODU≈Å NIEOBECNO≈öCI - DNI WOLNE =====

/**
 * Zapisuje wniosek o dzie≈Ñ wolny
 */
function submitDayOffRequest(dayOffData) {
  sprawdzUprawnienia();
  console.log('=== ZAPISYWANIE WNIOSKU O DZIE≈É WOLNY ===');
  console.log('Dane:', dayOffData);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Dni_wolne');
    
    if (!sheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Dni_wolne'
      };
    }
    
    // Pobierz ostatnie ID
    const lastRow = sheet.getLastRow();
    let newId = 1;
    if (lastRow > 1) {
      const lastId = sheet.getRange(lastRow, 1).getValue();
      newId = (parseInt(lastId) || 0) + 1;
    }
    
    // Mapowanie typ√≥w na czytelne nazwy
    const typeNames = {
      'nadgodziny': 'Odbi√≥r za nadgodziny',
      'swieto': 'Dzie≈Ñ za ≈õwiƒôto w sobotƒô',
      'opieka': 'Opieka nad dzieckiem (Art. 188 KP)',
      'sila_wyzsza': 'Si≈Ça wy≈ºsza (Art. 148¬π KP)',
      'wyjscie_prywatne': 'Wyj≈õcie prywatne',
      'inny': 'Inny'
    };
    
    const typeName = typeNames[dayOffData.type] || dayOffData.type;
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Przygotuj wiersz danych
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data, F=Typ, 
    // G=Godzina_od, H=Godzina_do, I=Powod, J=Status, K=Data_decyzji, L=Komentarz_kierownika
    const newRow = [
      newId,                          // A - ID
      dayOffData.login,               // B - Login
      dayOffData.name,                // C - Imie_Nazwisko
      dateStr,                        // D - Data_zlozenia
      dayOffData.date,                // E - Data
      typeName,                       // F - Typ
      dayOffData.timeFrom || '',      // G - Godzina_od
      dayOffData.timeTo || '',        // H - Godzina_do
      dayOffData.reason || '',        // I - Powod
      'OczekujƒÖcy',                   // J - Status
      '',                             // K - Data_decyzji
      ''                              // L - Komentarz_kierownika
    ];
    
    sheet.appendRow(newRow);
    
    console.log('‚úÖ Zapisano wniosek o dzie≈Ñ wolny #' + newId);
    
    return {
      success: true,
      message: 'Wniosek o dzie≈Ñ wolny zosta≈Ç z≈Ço≈ºony',
      requestId: newId
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd submitDayOffRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd zapisu: ' + error.toString()
    };
  }
}

/**
 * Pobiera wnioski o dzie≈Ñ wolny dla pracownika
 */
function getDayOffRequests(login) {
  sprawdzUprawnienia();
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Dni_wolne');
    
    if (!sheet) return [];
    
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return [];
    
    const data = sheet.getRange(2, 1, lastRow - 1, 12).getValues();
    const requests = [];
    
    data.forEach(row => {
      if (row[1] === login) {
        requests.push({
          id: row[0],
          date: row[4],
          type: row[5],
          timeFrom: row[6],
          timeTo: row[7],
          reason: row[8],
          status: row[9],
          dateSubmitted: row[3],
          dateDecision: row[10],
          managerComment: row[11]
        });
      }
    });
    
    // Sortuj: najnowsze pierwsze
    requests.sort((a, b) => b.id - a.id);
    
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getDayOffRequests:', error);
    return [];
  }
}

// ===== MODU≈Å NIEOBECNO≈öCI - URLOPY OKOLICZNO≈öCIOWE =====

/**
 * Zapisuje wniosek o urlop okoliczno≈õciowy
 */
function submitOccasionalLeaveRequest(occasionalData) {
  sprawdzUprawnienia();
  console.log('=== ZAPISYWANIE WNIOSKU O URLOP OKOLICZNO≈öCIOWY ===');
  console.log('Dane:', occasionalData);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    
    if (!sheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Urlopy_okolicznosciowe'
      };
    }
    
    // Pobierz ostatnie ID
    const lastRow = sheet.getLastRow();
    let newId = 1;
    if (lastRow > 1) {
      const lastId = sheet.getRange(lastRow, 1).getValue();
      newId = (parseInt(lastId) || 0) + 1;
    }
    
    // Mapowanie typ√≥w na czytelne nazwy i dni
    const typeInfo = {
      'slub_wlasny': { name: '≈ölub w≈Çasny', days: 2 },
      'slub_dziecka': { name: '≈ölub dziecka', days: 1 },
      'narodziny': { name: 'Narodziny dziecka', days: 2 },
      'zgon_malzonka': { name: 'Zgon ma≈Ç≈ºonka/dziecka/rodzica', days: 2 },
      'zgon_inny': { name: 'Zgon rodze≈Ñstwa/te≈õci√≥w/dziadk√≥w', days: 1 }
    };
    
    const info = typeInfo[occasionalData.type] || { name: occasionalData.type, days: 1 };
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Przygotuj wiersz danych
    // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data_od, F=Data_do, 
    // G=Dni, H=Typ_wydarzenia, I=Notatka, J=Status, K=Data_decyzji, L=Komentarz_kierownika
    const newRow = [
      newId,                          // A - ID
      occasionalData.login,           // B - Login
      occasionalData.name,            // C - Imie_Nazwisko
      dateStr,                        // D - Data_zlozenia
      occasionalData.dateStart,       // E - Data_od
      occasionalData.dateEnd,         // F - Data_do
      info.days,                      // G - Dni
      info.name,                      // H - Typ_wydarzenia
      occasionalData.note || '',      // I - Notatka
      'OczekujƒÖcy',                   // J - Status
      '',                             // K - Data_decyzji
      ''                              // L - Komentarz_kierownika
    ];
    
    sheet.appendRow(newRow);
    
    console.log('‚úÖ Zapisano wniosek o urlop okoliczno≈õciowy #' + newId);
    
    return {
      success: true,
      message: 'Wniosek o urlop okoliczno≈õciowy zosta≈Ç z≈Ço≈ºony (' + info.days + ' dni)',
      requestId: newId
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd submitOccasionalLeaveRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd zapisu: ' + error.toString()
    };
  }
}

/**
 * Pobiera wnioski o urlop okoliczno≈õciowy dla pracownika
 */
function getOccasionalLeaveRequests(login) {
  sprawdzUprawnienia();
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    
    if (!sheet) return [];
    
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return [];
    
    const data = sheet.getRange(2, 1, lastRow - 1, 12).getValues();
    const requests = [];
    
    data.forEach(row => {
      if (row[1] === login) {
        requests.push({
          id: row[0],
          dateFrom: row[4],
          dateTo: row[5],
          days: row[6],
          type: row[7],
          note: row[8],
          status: row[9],
          dateSubmitted: row[3],
          dateDecision: row[10],
          managerComment: row[11]
        });
      }
    });
    
    // Sortuj: najnowsze pierwsze
    requests.sort((a, b) => b.id - a.id);
    
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getOccasionalLeaveRequests:', error);
    return [];
  }
}

// ===== MODU≈Å NIEOBECNO≈öCI - PLAN ROCZNY =====

/**
 * Zapisuje plan roczny urlop√≥w
 * Obs≈Çuguje: nowe plany, aktualizacjƒô oczekujƒÖcych, dodawanie do zatwierdzonych
 */
function submitYearPlanRequest(planData) {
  sprawdzUprawnienia();
  console.log('=== ZAPISYWANIE PLANU ROCZNEGO ===');
  console.log('Dane:', JSON.stringify(planData));
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet) {
      return {
        success: false,
        message: 'Nie znaleziono arkusza Plan_roczny'
      };
    }
    
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Pobierz istniejƒÖce dane
    const lastRow = sheet.getLastRow();
    let existingPendingRowIndex = -1;
    let existingPendingDates = [];
    
    if (lastRow > 1) {
      const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
      
      for (let i = 0; i < data.length; i++) {
        const rowLogin = data[i][1];
        const rowYear = data[i][4];
        const rowStatus = data[i][7];
        const rowDates = data[i][6];
        
        if (rowLogin === planData.login && rowYear == planData.year) {
          if (rowStatus === 'OczekujƒÖcy') {
            existingPendingRowIndex = i + 2; // +2 bo indeks 0 = wiersz 2
            try {
              existingPendingDates = typeof rowDates === 'string' ? JSON.parse(rowDates) : rowDates;
              if (!Array.isArray(existingPendingDates)) existingPendingDates = [];
            } catch (e) {
              existingPendingDates = [];
            }
            console.log('Znaleziono istniejƒÖcy plan oczekujƒÖcy w wierszu:', existingPendingRowIndex);
            break;
          }
        }
      }
    }
    
    // Oblicz nowƒÖ listƒô dat
    let finalDates = [];
    
    if (planData.newDates && planData.removedDates) {
      // Nowy format - mamy info o dodanych i usuniƒôtych
      
      // Zacznij od istniejƒÖcych oczekujƒÖcych
      finalDates = [...existingPendingDates];
      
      // Usu≈Ñ dni oznaczone do usuniƒôcia
      if (planData.removedDates && planData.removedDates.length > 0) {
        finalDates = finalDates.filter(d => !planData.removedDates.includes(d));
        console.log('Usuniƒôto dni:', planData.removedDates.length);
      }
      
      // Dodaj nowe dni (unikajƒÖc duplikat√≥w)
      if (planData.newDates && planData.newDates.length > 0) {
        planData.newDates.forEach(d => {
          if (!finalDates.includes(d)) {
            finalDates.push(d);
          }
        });
        console.log('Dodano nowych dni:', planData.newDates.length);
      }
    } else if (planData.dates) {
      // Stary format - kompatybilno≈õƒá wsteczna
      finalDates = planData.dates;
    }
    
    // Sortuj daty
    finalDates.sort();
    
    console.log('Finalna lista dat:', finalDates.length, 'dni');
    
    // Je≈õli nie ma ≈ºadnych dat - usu≈Ñ plan (je≈õli istnieje)
    if (finalDates.length === 0) {
      if (existingPendingRowIndex > 0) {
        sheet.deleteRow(existingPendingRowIndex);
        console.log('Usuniƒôto pusty plan');
        return {
          success: true,
          message: 'Plan roczny zosta≈Ç usuniƒôty (brak zaplanowanych dni)'
        };
      } else {
        return {
          success: false,
          message: 'Nie ma ≈ºadnych dni do zapisania'
        };
      }
    }
    
    // Zapisz lub zaktualizuj plan
    if (existingPendingRowIndex > 0) {
      // Aktualizuj istniejƒÖcy plan oczekujƒÖcy
      sheet.getRange(existingPendingRowIndex, 4).setValue(dateStr);  // D - Data_zlozenia (aktualizacja)
      sheet.getRange(existingPendingRowIndex, 6).setValue(finalDates.length);  // F - Liczba_dni
      sheet.getRange(existingPendingRowIndex, 7).setValue(JSON.stringify(finalDates));  // G - Lista_dat
      // Status pozostaje "OczekujƒÖcy"
      
      console.log('Zaktualizowano istniejƒÖcy plan');
      
      let message = `Plan roczny na ${planData.year} zaktualizowany (${finalDates.length} dni)`;
      if (planData.newDates && planData.newDates.length > 0) {
        message += ` - dodano ${planData.newDates.length}`;
      }
      if (planData.removedDates && planData.removedDates.length > 0) {
        message += ` - usuniƒôto ${planData.removedDates.length}`;
      }
      
      return {
        success: true,
        message: message
      };
      
    } else {
      // Utw√≥rz nowy plan
      let newId = 1;
      if (lastRow > 1) {
        const lastId = sheet.getRange(lastRow, 1).getValue();
        newId = (parseInt(lastId) || 0) + 1;
      }
      
      // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Rok, F=Liczba_dni,
      // G=Lista_dat, H=Status, I=Data_decyzji, J=Komentarz_kierownika
      const newRow = [
        newId,
        planData.login,
        planData.name,
        dateStr,
        planData.year,
        finalDates.length,
        JSON.stringify(finalDates),
        'OczekujƒÖcy',
        '',
        ''
      ];
      
      sheet.appendRow(newRow);
      
      console.log('‚úÖ Zapisano nowy plan roczny #' + newId);
      
      return {
        success: true,
        message: `Plan roczny na ${planData.year} zosta≈Ç z≈Ço≈ºony (${finalDates.length} dni)`,
        requestId: newId
      };
    }
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd submitYearPlanRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd zapisu: ' + error.toString()
    };
  }
}

/**
 * Pobiera plan roczny dla pracownika
 */
function getYearPlanRequests(login, year) {
  sprawdzUprawnienia();
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet) return [];
    
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return [];
    
    const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
    const requests = [];
    
    data.forEach(row => {
      // Filtruj po loginie, opcjonalnie po roku
      if (row[1] === login) {
        if (year && row[4] !== year) return;
        
        let dates = [];
        try {
          dates = JSON.parse(row[6]);
        } catch (e) {
          dates = [];
        }
        
        requests.push({
          id: row[0],
          year: row[4],
          daysCount: row[5],
          dates: dates,
          status: row[7],
          dateSubmitted: row[3],
          dateDecision: row[8],
          managerComment: row[9]
        });
      }
    });
    
    // Sortuj: najnowsze pierwsze
    requests.sort((a, b) => b.id - a.id);
    
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getYearPlanRequests:', error);
    return [];
  }
}

// ===== MODU≈Å NIEOBECNO≈öCI - PODSUMOWANIE =====

/**
 * Aktualizuje arkusz Podsumowanie_nieobecnosci dla wszystkich pracownik√≥w
 * Wywo≈Çaj rƒôcznie lub przez trigger (np. codziennie)
 */
function updateAbsenceSummary() {
  sprawdzUprawnienia();
  console.log('=== AKTUALIZACJA PODSUMOWANIA NIEOBECNO≈öCI ===');
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    
    // Pobierz arkusze ≈∫r√≥d≈Çowe
    const usersSheet = ss.getSheetByName(SHEETS.USERS);
    const vacationSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
    const dayOffSheet = ss.getSheetByName('Dni_wolne');
    const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    const l4Sheet = ss.getSheetByName(SHEETS.L4 || 'Zwolnienia_lekarskie');
    const summarySheet = ss.getSheetByName('Podsumowanie_nieobecnosci');
    
    if (!summarySheet) {
      console.error('Brak arkusza Podsumowanie_nieobecnosci');
      return { success: false, message: 'Brak arkusza podsumowania' };
    }
    
    // Pobierz listƒô pracownik√≥w
    const usersData = usersSheet.getDataRange().getValues();
    const usersHeaders = usersData[0];
    
    const loginIdx = usersHeaders.indexOf('login') !== -1 ? usersHeaders.indexOf('login') : usersHeaders.indexOf('Login');
    const nameIdx = usersHeaders.indexOf('imie_nazwisko') !== -1 ? usersHeaders.indexOf('imie_nazwisko') : usersHeaders.indexOf('Imiƒô Nazwisko');
    const vacPrzysIdx = usersHeaders.indexOf('Urlop_przys≈ÇugujƒÖcy');
    const vacWykIdx = usersHeaders.indexOf('Urlop_wykorzystany');
    const vacPozIdx = usersHeaders.indexOf('Urlop_pozosta≈Çy');
    
    // Zbierz dane z ka≈ºdego arkusza
    const currentYear = new Date().getFullYear();
    
    // Dane z Dni_wolne
    const dayOffData = dayOffSheet ? dayOffSheet.getDataRange().getValues() : [];
    
    // Dane z Urlopy_okolicznosciowe
    const occasionalData = occasionalSheet ? occasionalSheet.getDataRange().getValues() : [];
    
    // Dane z L4
    const l4Data = l4Sheet ? l4Sheet.getDataRange().getValues() : [];
    
    // Przygotuj podsumowanie dla ka≈ºdego pracownika
    const summaryData = [];
    
    for (let i = 1; i < usersData.length; i++) {
      const login = usersData[i][loginIdx];
      const name = usersData[i][nameIdx];
      
      if (!login) continue;
      
      // Urlopy z arkusza Pracownicy
      const urlopPrzys = usersData[i][vacPrzysIdx] || 0;
      const urlopWyk = usersData[i][vacWykIdx] || 0;
      const urlopPoz = usersData[i][vacPozIdx] || 0;
      
      // Zlicz dni wolne (tylko zatwierdzone, w bie≈ºƒÖcym roku)
      let dniWolneSuma = 0;
      let opiekaArt188 = 0;
      let silaWyzsza = 0;
      
      for (let j = 1; j < dayOffData.length; j++) {
        const row = dayOffData[j];
        if (row[1] !== login) continue;
        if (row[9] !== 'Zatwierdzony') continue;
        
        const dataWniosku = new Date(row[4]);
        if (dataWniosku.getFullYear() !== currentYear) continue;
        
        const typ = row[5];
        
        if (typ.includes('Opieka nad dzieckiem')) {
          opiekaArt188++;
        } else if (typ.includes('Si≈Ça wy≈ºsza')) {
          silaWyzsza++;
        } else {
          dniWolneSuma++;
        }
      }
      
      // Zlicz urlopy okoliczno≈õciowe (tylko zatwierdzone, w bie≈ºƒÖcym roku)
      let urlopOkolSuma = 0;
      
      for (let j = 1; j < occasionalData.length; j++) {
        const row = occasionalData[j];
        if (row[1] !== login) continue;
        if (row[9] !== 'Zatwierdzony') continue;
        
        const dataOd = new Date(row[4]);
        if (dataOd.getFullYear() !== currentYear) continue;
        
        urlopOkolSuma += parseInt(row[6]) || 0;
      }
      
      // Zlicz dni L4 (w bie≈ºƒÖcym roku)
      let l4Suma = 0;
      
      for (let j = 1; j < l4Data.length; j++) {
        const row = l4Data[j];
        if (row[1] !== login) continue;
        
        const dataOd = new Date(row[3]);
        if (dataOd.getFullYear() !== currentYear) continue;
        
        l4Suma += parseInt(row[5]) || 0;
      }
      
      // Dodaj wiersz do podsumowania
      // A=Login, B=Imie_Nazwisko, C=Urlop_przyslugujacy, D=Urlop_wykorzystany, E=Urlop_pozostaly,
      // F=Dni_wolne_suma, G=Opieka_art188, H=Opieka_limit, I=Sila_wyzsza, J=Sila_wyzsza_limit,
      // K=Urlopy_okolicznosciowe, L=L4_dni
      summaryData.push([
        login,
        name,
        urlopPrzys,
        urlopWyk,
        urlopPoz,
        dniWolneSuma,
        opiekaArt188,
        2,  // Opieka_limit (ustawowy)
        silaWyzsza,
        2,  // Sila_wyzsza_limit (ustawowy)
        urlopOkolSuma,
        l4Suma
      ]);
    }
    
    // Wyczy≈õƒá arkusz (poza nag≈Ç√≥wkiem) i wstaw nowe dane
    const lastRow = summarySheet.getLastRow();
    if (lastRow > 1) {
      summarySheet.deleteRows(2, lastRow - 1);
    }
    
    if (summaryData.length > 0) {
      summarySheet.getRange(2, 1, summaryData.length, 12).setValues(summaryData);
    }
    
    console.log('‚úÖ Zaktualizowano podsumowanie dla ' + summaryData.length + ' pracownik√≥w');
    
    return {
      success: true,
      message: 'Podsumowanie zaktualizowane dla ' + summaryData.length + ' pracownik√≥w'
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd updateAbsenceSummary:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd aktualizacji: ' + error.toString()
    };
  }
}

/**
 * Pobiera podsumowanie nieobecno≈õci dla konkretnego pracownika
 */
function getAbsenceSummaryForUser(login) {
  sprawdzUprawnienia();
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const summarySheet = ss.getSheetByName('Podsumowanie_nieobecnosci');
    
    if (!summarySheet) {
      // Je≈õli brak arkusza, zwr√≥ƒá domy≈õlne warto≈õci
      return {
        urlopPrzys≈ÇugujƒÖcy: 0,
        urlopWykorzystany: 0,
        urlopPozosta≈Çy: 0,
        dniWolne: 0,
        opiekaArt188: 0,
        opiekaLimit: 2,
        silaWyzsza: 0,
        silaWyszaLimit: 2,
        urlopOkolicznosciowy: 0,
        l4Dni: 0
      };
    }
    
    const data = summarySheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === login) {
        return {
          urlopPrzys≈ÇugujƒÖcy: data[i][2] || 0,
          urlopWykorzystany: data[i][3] || 0,
          urlopPozosta≈Çy: data[i][4] || 0,
          dniWolne: data[i][5] || 0,
          opiekaArt188: data[i][6] || 0,
          opiekaLimit: data[i][7] || 2,
          silaWyzsza: data[i][8] || 0,
          silaWyszaLimit: data[i][9] || 2,
          urlopOkolicznosciowy: data[i][10] || 0,
          l4Dni: data[i][11] || 0
        };
      }
    }
    
    // Nie znaleziono - zwr√≥ƒá domy≈õlne
    return {
      urlopPrzys≈ÇugujƒÖcy: 0,
      urlopWykorzystany: 0,
      urlopPozosta≈Çy: 0,
      dniWolne: 0,
      opiekaArt188: 0,
      opiekaLimit: 2,
      silaWyzsza: 0,
      silaWyszaLimit: 2,
      urlopOkolicznosciowy: 0,
      l4Dni: 0
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getAbsenceSummaryForUser:', error);
    return null;
  }
}

// ===== MODU≈Å NIEOBECNO≈öCI - POBIERANIE OCZEKUJƒÑCYCH WNIOSK√ìW =====

/**
 * Pobiera liczbƒô oczekujƒÖcych wniosk√≥w wed≈Çug typu
 */
function getPendingAbsenceCountsByType() {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE LICZNIK√ìW OCZEKUJƒÑCYCH WNIOSK√ìW ===');
  
  const counts = {
    vacation: 0,
    dayoff: 0,
    occasional: 0,
    yearplan: 0
  };
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    
    // 1. Urlopy wypoczynkowe
    const vacationSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
    if (vacationSheet && vacationSheet.getLastRow() > 1) {
      const vacData = vacationSheet.getRange(2, 8, vacationSheet.getLastRow() - 1, 1).getValues();
      vacData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') counts.vacation++;
      });
    }
    
    // 2. Dni wolne
    const dayOffSheet = ss.getSheetByName('Dni_wolne');
    if (dayOffSheet && dayOffSheet.getLastRow() > 1) {
      const dayOffData = dayOffSheet.getRange(2, 10, dayOffSheet.getLastRow() - 1, 1).getValues();
      dayOffData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') counts.dayoff++;
      });
    }
    
    // 3. Urlopy okoliczno≈õciowe
    const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    if (occasionalSheet && occasionalSheet.getLastRow() > 1) {
      const occasionalData = occasionalSheet.getRange(2, 10, occasionalSheet.getLastRow() - 1, 1).getValues();
      occasionalData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') counts.occasional++;
      });
    }
    
    // 4. Plan roczny
    const yearPlanSheet = ss.getSheetByName('Plan_roczny');
    if (yearPlanSheet && yearPlanSheet.getLastRow() > 1) {
      const yearPlanData = yearPlanSheet.getRange(2, 8, yearPlanSheet.getLastRow() - 1, 1).getValues();
      yearPlanData.forEach(row => {
        if (row[0] === 'OczekujƒÖcy') counts.yearplan++;
      });
    }
    
    console.log('‚úÖ Liczniki:', counts);
    return counts;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getPendingAbsenceCountsByType:', error);
    return counts;
  }
}

/**
 * Pobiera oczekujƒÖce wnioski o dzie≈Ñ wolny (dla kierownika)
 */
function getPendingDayOffRequests() {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE OCZEKUJƒÑCYCH WNIOSK√ìW O DZIE≈É WOLNY ===');
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Dni_wolne');
    
    if (!sheet || sheet.getLastRow() <= 1) return [];
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 12).getValues();
    const requests = [];
    
    data.forEach((row, index) => {
      if (row[9] === 'OczekujƒÖcy') {
        requests.push({
          id: row[0],
          login: row[1],
          name: row[2],
          dateSubmitted: formatDate(row[3]),
          date: formatDate(row[4]),
          type: row[5],
          timeFrom: row[6] || '',
          timeTo: row[7] || '',
          reason: row[8] || '',
          status: row[9],
          rowIndex: index + 2
        });
      }
    });
    
    console.log('‚úÖ Znaleziono wniosk√≥w o dzie≈Ñ wolny:', requests.length);
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getPendingDayOffRequests:', error);
    return [];
  }
}

/**
 * Pobiera oczekujƒÖce wnioski o urlop okoliczno≈õciowy (dla kierownika)
 */
function getPendingOccasionalLeaveRequests() {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE OCZEKUJƒÑCYCH WNIOSK√ìW O URLOP OKOLICZNO≈öCIOWY ===');
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    
    if (!sheet || sheet.getLastRow() <= 1) return [];
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 12).getValues();
    const requests = [];
    
    data.forEach((row, index) => {
      if (row[9] === 'OczekujƒÖcy') {
        requests.push({
          id: row[0],
          login: row[1],
          name: row[2],
          dateSubmitted: formatDate(row[3]),
          dateFrom: formatDate(row[4]),
          dateTo: formatDate(row[5]),
          days: row[6],
          type: row[7],
          note: row[8] || '',
          status: row[9],
          rowIndex: index + 2
        });
      }
    });
    
    console.log('‚úÖ Znaleziono wniosk√≥w o urlop okoliczno≈õciowy:', requests.length);
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getPendingOccasionalLeaveRequests:', error);
    return [];
  }
}

/**
 * Pobiera oczekujƒÖce plany roczne (dla kierownika)
 */
function getPendingYearPlanRequests() {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE OCZEKUJƒÑCYCH PLAN√ìW ROCZNYCH ===');
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet || sheet.getLastRow() <= 1) return [];
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 10).getValues();
    const requests = [];
    
    data.forEach((row, index) => {
      if (row[7] === 'OczekujƒÖcy') {
        requests.push({
          id: row[0],
          login: row[1],
          name: row[2],
          dateSubmitted: formatDate(row[3]),
          year: row[4],
          daysCount: row[5],
          dates: row[6],
          status: row[7],
          rowIndex: index + 2
        });
      }
    });
    
    console.log('‚úÖ Znaleziono plan√≥w rocznych:', requests.length);
    return requests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getPendingYearPlanRequests:', error);
    return [];
  }
}

// ===== MODU≈Å NIEOBECNO≈öCI - PRZETWARZANIE WNIOSK√ìW =====

/**
 * Przetwarza wniosek o dzie≈Ñ wolny (zatwierdza lub odrzuca)
 */
function processDayOffRequest(requestId, decision, managerComment) {
  sprawdzUprawnienia();
  console.log('=== PRZETWARZANIE WNIOSKU O DZIE≈É WOLNY ===');
  console.log('ID:', requestId, 'Decyzja:', decision);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Dni_wolne');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Dni_wolne' };
    }
    
    // Znajd≈∫ wiersz z wnioskiem
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == requestId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, message: 'Nie znaleziono wniosku #' + requestId };
    }
    
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Aktualizuj kolumny: J=Status, K=Data_decyzji, L=Komentarz_kierownika
    sheet.getRange(rowIndex, 10).setValue(decision);           // J - Status
    sheet.getRange(rowIndex, 11).setValue(dateStr);            // K - Data_decyzji
    sheet.getRange(rowIndex, 12).setValue(managerComment || ''); // L - Komentarz_kierownika
    
    console.log('‚úÖ Wniosek o dzie≈Ñ wolny #' + requestId + ' - ' + decision);
    
    // Aktualizuj podsumowanie nieobecno≈õci
    try {
      updateAbsenceSummary();
    } catch (e) {
      console.log('Uwaga: nie uda≈Ço siƒô zaktualizowaƒá podsumowania:', e);
    }
    
    return {
      success: true,
      message: 'Wniosek o dzie≈Ñ wolny ' + (decision === 'Zatwierdzony' ? 'zatwierdzony' : 'odrzucony')
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd processDayOffRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd przetwarzania: ' + error.toString()
    };
  }
}

/**
 * Przetwarza wniosek o urlop okoliczno≈õciowy (zatwierdza lub odrzuca)
 */
function processOccasionalLeaveRequest(requestId, decision, managerComment) {
  sprawdzUprawnienia();
  console.log('=== PRZETWARZANIE WNIOSKU O URLOP OKOLICZNO≈öCIOWY ===');
  console.log('ID:', requestId, 'Decyzja:', decision);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Urlopy_okolicznosciowe' };
    }
    
    // Znajd≈∫ wiersz z wnioskiem
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == requestId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, message: 'Nie znaleziono wniosku #' + requestId };
    }
    
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Aktualizuj kolumny: J=Status, K=Data_decyzji, L=Komentarz_kierownika
    sheet.getRange(rowIndex, 10).setValue(decision);           // J - Status
    sheet.getRange(rowIndex, 11).setValue(dateStr);            // K - Data_decyzji
    sheet.getRange(rowIndex, 12).setValue(managerComment || ''); // L - Komentarz_kierownika
    
    console.log('‚úÖ Wniosek o urlop okoliczno≈õciowy #' + requestId + ' - ' + decision);
    
    // Aktualizuj podsumowanie nieobecno≈õci
    try {
      updateAbsenceSummary();
    } catch (e) {
      console.log('Uwaga: nie uda≈Ço siƒô zaktualizowaƒá podsumowania:', e);
    }
    
    return {
      success: true,
      message: 'Wniosek o urlop okoliczno≈õciowy ' + (decision === 'Zatwierdzony' ? 'zatwierdzony' : 'odrzucony')
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd processOccasionalLeaveRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd przetwarzania: ' + error.toString()
    };
  }
}

/**
 * Przetwarza plan roczny (zatwierdza lub odrzuca)
 */
function processYearPlanRequest(requestId, decision, managerComment) {
  sprawdzUprawnienia();
  console.log('=== PRZETWARZANIE PLANU ROCZNEGO ===');
  console.log('ID:', requestId, 'Decyzja:', decision);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Plan_roczny' };
    }
    
    // Znajd≈∫ wiersz z wnioskiem
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == requestId) {
        rowIndex = i + 1;
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, message: 'Nie znaleziono planu #' + requestId };
    }
    
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Aktualizuj kolumny: H=Status, I=Data_decyzji, J=Komentarz_kierownika
    sheet.getRange(rowIndex, 8).setValue(decision);            // H - Status
    sheet.getRange(rowIndex, 9).setValue(dateStr);             // I - Data_decyzji
    sheet.getRange(rowIndex, 10).setValue(managerComment || ''); // J - Komentarz_kierownika
    
    console.log('‚úÖ Plan roczny #' + requestId + ' - ' + decision);
    
    // Aktualizuj podsumowanie nieobecno≈õci
    try {
      updateAbsenceSummary();
    } catch (e) {
      console.log('Uwaga: nie uda≈Ço siƒô zaktualizowaƒá podsumowania:', e);
    }
    
    return {
      success: true,
      message: 'Plan roczny ' + (decision === 'Zatwierdzony' ? 'zatwierdzony' : 'odrzucony')
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd processYearPlanRequest:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd przetwarzania: ' + error.toString()
    };
  }
}

/**
 * Przetwarza plan roczny z wybranymi datami (zatwierdza ca≈Ço≈õƒá lub czƒô≈õƒá)
 */
function processYearPlanWithDates(requestId, decision, managerComment, selectedDates) {
  sprawdzUprawnienia();
  console.log('=== PRZETWARZANIE PLANU ROCZNEGO Z DATAMI ===');
  console.log('ID:', requestId, 'Decyzja:', decision);
  console.log('Zatwierdzone daty:', selectedDates);
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Plan_roczny' };
    }
    
    // Znajd≈∫ wiersz z wnioskiem
    const data = sheet.getDataRange().getValues();
    let rowIndex = -1;
    let originalDates = [];
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == requestId) {
        rowIndex = i + 1;
        // Pobierz oryginalne daty
        try {
          originalDates = typeof data[i][6] === 'string' ? JSON.parse(data[i][6]) : data[i][6];
        } catch(e) {
          originalDates = [];
        }
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { success: false, message: 'Nie znaleziono planu #' + requestId };
    }
    
    const now = new Date();
    const dateStr = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    // Aktualizuj kolumny
    sheet.getRange(rowIndex, 6).setValue(selectedDates.length);  // F - Liczba_dni (zaktualizowana)
    sheet.getRange(rowIndex, 7).setValue(JSON.stringify(selectedDates));  // G - Lista_dat (tylko zatwierdzone)
    sheet.getRange(rowIndex, 8).setValue(decision);              // H - Status
    sheet.getRange(rowIndex, 9).setValue(dateStr);               // I - Data_decyzji
    sheet.getRange(rowIndex, 10).setValue(managerComment || ''); // J - Komentarz_kierownika
    
    console.log('‚úÖ Plan roczny #' + requestId + ' - ' + decision);
    console.log('Zatwierdzone dni: ' + selectedDates.length + '/' + originalDates.length);
    
    let message = '';
    if (decision === 'Zatwierdzony') {
      message = 'Plan roczny zatwierdzony (' + selectedDates.length + ' dni)';
    } else if (decision === 'Czƒô≈õciowo zatwierdzony') {
      message = 'Plan czƒô≈õciowo zatwierdzony (' + selectedDates.length + '/' + originalDates.length + ' dni)';
    } else {
      message = 'Plan roczny odrzucony';
    }
    
    // Aktualizuj podsumowanie nieobecno≈õci
    try {
      updateAbsenceSummary();
    } catch (e) {
      console.log('Uwaga: nie uda≈Ço siƒô zaktualizowaƒá podsumowania:', e);
    }
    
    return {
      success: true,
      message: message
    };
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd processYearPlanWithDates:', error);
    return {
      success: false,
      message: 'B≈ÇƒÖd przetwarzania: ' + error.toString()
    };
  }
}

// ===== GENEROWANIE PDF DLA DNI WOLNYCH =====

/**
 * Generuje PDF dla wniosku o dzie≈Ñ wolny
 */
function generateDayOffPDF(requestId) {
  sprawdzUprawnienia();
  console.log('=== GENEROWANIE PDF DLA DNIA WOLNEGO:', requestId, '===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Dni_wolne');
  
  if (!sheet) {
    throw new Error('Arkusz Dni_wolne nie istnieje');
  }
  
  const data = sheet.getDataRange().getValues();
  
  let requestRow = null;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == requestId) {
      requestRow = data[i];
      break;
    }
  }
  
  if (!requestRow) {
    throw new Error('Nie znaleziono wniosku o ID: ' + requestId);
  }
  
  // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data, F=Typ, 
  // G=Godzina_od, H=Godzina_do, I=Powod, J=Status, K=Data_decyzji, L=Komentarz_kierownika
  const request = {
    id: requestRow[0],
    login: requestRow[1],
    name: requestRow[2],
    dateSubmitted: formatDate(requestRow[3]),
    date: formatDate(requestRow[4]),
    type: requestRow[5],
    timeFrom: requestRow[6] || '',
    timeTo: requestRow[7] || '',
    reason: requestRow[8] || '',
    status: requestRow[9],
    dateDecision: requestRow[10] ? formatDate(requestRow[10]) : '',
    managerComment: requestRow[11] || ''
  };
  
  const html = generateDayOffRequestHTML(request);
  
  const blob = Utilities.newBlob(html, 'text/html', 'wniosek.html');
  const pdf = blob.getAs('application/pdf');
  const fileName = `Wniosek_dzien_wolny_${request.name.replace(/\s+/g, '_')}_${request.date}.pdf`;
  pdf.setName(fileName);
  
  console.log('PDF wygenerowany:', fileName);
  
  return {
    success: true,
    fileName: fileName,
    pdfBlob: pdf,
    downloadUrl: createDownloadUrl(pdf)
  };
}

/**
 * Generuje HTML dla wniosku o dzie≈Ñ wolny
 */
function generateDayOffRequestHTML(request) {
  const statusLabel = request.status === 'Zatwierdzony' ? '‚òë Zatwierdzam wniosek' : '‚òê Zatwierdzam wniosek';
  const statusReject = request.status === 'Odrzucony' ? '‚òë Odmawiam udzielenia dnia wolnego' : '‚òê Odmawiam udzielenia dnia wolnego';
  
  // Czy to wyj≈õcie prywatne (z godzinami)?
  const isPrivateExit = request.type.includes('Wyj≈õcie prywatne') || (request.timeFrom && request.timeTo);
  
  // Mapowanie typu na podstawƒô prawnƒÖ
  let legalBasis = '';
  if (request.type.includes('Opieka nad dzieckiem')) {
    legalBasis = 'Art. 188 Kodeksu Pracy - 2 dni w roku kalendarzowym';
  } else if (request.type.includes('Si≈Ça wy≈ºsza')) {
    legalBasis = 'Art. 148¬π Kodeksu Pracy - 2 dni w roku kalendarzowym';
  } else if (request.type.includes('Odbi√≥r za nadgodziny')) {
    legalBasis = 'Art. 151¬≤ ¬ß 3 Kodeksu Pracy - odbi√≥r czasu wolnego za nadgodziny';
  } else if (request.type.includes('Dzie≈Ñ za ≈õwiƒôto')) {
    legalBasis = 'Art. 130 ¬ß 2 Kodeksu Pracy - dzie≈Ñ wolny za ≈õwiƒôto przypadajƒÖce w sobotƒô';
  }
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    @page {
      size: A4;
      margin: 1.5cm;
    }
    body {
      font-family: Arial, sans-serif;
      font-size: 10pt;
      line-height: 1.3;
      color: #000;
      margin: 0;
      padding: 0;
    }
    .header {
      text-align: center;
      font-size: 13pt;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 8px;
      border: 2px solid #000;
      background-color: #e3f2fd;
    }
    .section {
      margin-bottom: 12px;
    }
    .field {
      margin: 4px 0;
      padding-left: 10px;
      font-size: 9.5pt;
    }
    .field-label {
      font-weight: bold;
      display: inline-block;
      width: 180px;
    }
    .box {
      border: 1px solid #000;
      padding: 10px;
      margin: 10px 0;
      background-color: #f9f9f9;
    }
    .signature-section {
      margin-top: 20px;
      border-top: 2px solid #000;
      padding-top: 12px;
    }
    .signature-box {
      display: inline-block;
      width: 48%;
      text-align: center;
      vertical-align: top;
    }
    .signature-line {
      border-bottom: 1px solid #000;
      height: 35px;
      margin-bottom: 4px;
    }
    .footer {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #ccc;
      font-size: 8pt;
      color: #666;
      text-align: center;
    }
    .decision-box {
      border: 2px solid #000;
      padding: 10px;
      margin: 12px 0;
      background-color: #fff;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 9.5pt;
    }
    table td {
      padding: 4px 6px;
      border: 1px solid #999;
    }
    table td.label {
      font-weight: bold;
      width: 180px;
      background-color: #e3f2fd;
    }
    .compact {
      margin: 6px 0;
      font-size: 9pt;
    }
    .legal-basis {
      font-size: 8pt;
      color: #555;
      font-style: italic;
      margin-top: 8px;
      padding: 5px;
      background-color: #fff3e0;
      border-left: 3px solid #ff9800;
    }
  </style>
</head>
<body>

<div class="header">
  WNIOSEK O UDZIELENIE DNIA WOLNEGO
</div>

<div class="section">
  <div class="field">
    <span class="field-label">Imiƒô i nazwisko:</span>
    <span class="field-value"><strong>${request.name}</strong></span>
  </div>
  <div class="field">
    <span class="field-label">Login:</span>
    <span class="field-value">${request.login}</span>
  </div>
  <div class="field">
    <span class="field-label">Data z≈Ço≈ºenia wniosku:</span>
    <span class="field-value">${request.dateSubmitted}</span>
  </div>
</div>

<div class="box">
  <div style="font-weight: bold; margin-bottom: 8px;">Proszƒô o udzielenie dnia wolnego:</div>
  
  <table>
    <tr>
      <td class="label">Data:</td>
      <td><strong>${request.date}</strong></td>
    </tr>
    <tr>
      <td class="label">Rodzaj:</td>
      <td><strong>${request.type}</strong></td>
    </tr>
    ${isPrivateExit ? `
    <tr>
      <td class="label">Godziny nieobecno≈õci:</td>
      <td><strong>${request.timeFrom} - ${request.timeTo}</strong></td>
    </tr>
    ` : ''}
  </table>
  
  ${request.reason ? `
  <div class="compact">
    <strong>Uzasadnienie:</strong> <em>${request.reason}</em>
  </div>
  ` : ''}
  
  ${legalBasis ? `
  <div class="legal-basis">
    <strong>Podstawa prawna:</strong> ${legalBasis}
  </div>
  ` : ''}
</div>

<div class="signature-section">
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracownika</div>
  </div>
  
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracodawcy</div>
  </div>
</div>

${request.status !== 'OczekujƒÖcy' ? `
<div class="decision-box">
  <div style="font-weight: bold; margin-bottom: 8px;">Decyzja pracodawcy:</div>
  
  <div class="compact">
    ${statusLabel}
  </div>
  <div class="compact">
    ${statusReject}
  </div>
  
  ${request.managerComment ? `
  <div class="compact" style="margin-top: 8px;">
    <strong>Uwagi kierownika:</strong> <em>${request.managerComment}</em>
  </div>
  ` : ''}
  
  ${request.dateDecision ? `
  <div class="compact">
    <strong>Data decyzji:</strong> ${request.dateDecision}
  </div>
  ` : ''}
</div>
` : ''}

<div class="footer">
  Wniosek nr: ${request.id} | Wygenerowano: ${Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd HH:mm')}<br>
  System Magazynowy - Rejestrator Czasu Pracy
</div>

</body>
</html>
  `;
  
  return html;
}

// ===== GENEROWANIE PDF DLA URLOP√ìW OKOLICZNO≈öCIOWYCH =====

/**
 * Generuje PDF dla wniosku o urlop okoliczno≈õciowy
 */
function generateOccasionalLeavePDF(requestId) {
  sprawdzUprawnienia();
  console.log('=== GENEROWANIE PDF DLA URLOPU OKOLICZNO≈öCIOWEGO:', requestId, '===');
  
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
  
  if (!sheet) {
    throw new Error('Arkusz Urlopy_okolicznosciowe nie istnieje');
  }
  
  const data = sheet.getDataRange().getValues();
  
  let requestRow = null;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] == requestId) {
      requestRow = data[i];
      break;
    }
  }
  
  if (!requestRow) {
    throw new Error('Nie znaleziono wniosku o ID: ' + requestId);
  }
  
  // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Data_od, F=Data_do, 
  // G=Dni, H=Typ_wydarzenia, I=Notatka, J=Status, K=Data_decyzji, L=Komentarz_kierownika
  const request = {
    id: requestRow[0],
    login: requestRow[1],
    name: requestRow[2],
    dateSubmitted: formatDate(requestRow[3]),
    dateFrom: formatDate(requestRow[4]),
    dateTo: formatDate(requestRow[5]),
    days: requestRow[6],
    type: requestRow[7],
    note: requestRow[8] || '',
    status: requestRow[9],
    dateDecision: requestRow[10] ? formatDate(requestRow[10]) : '',
    managerComment: requestRow[11] || ''
  };
  
  const html = generateOccasionalLeaveRequestHTML(request);
  
  const blob = Utilities.newBlob(html, 'text/html', 'wniosek.html');
  const pdf = blob.getAs('application/pdf');
  const fileName = `Wniosek_urlop_okolicznosciowy_${request.name.replace(/\s+/g, '_')}_${request.dateFrom}.pdf`;
  pdf.setName(fileName);
  
  console.log('PDF wygenerowany:', fileName);
  
  return {
    success: true,
    fileName: fileName,
    pdfBlob: pdf,
    downloadUrl: createDownloadUrl(pdf)
  };
}

/**
 * Generuje HTML dla wniosku o urlop okoliczno≈õciowy
 */
function generateOccasionalLeaveRequestHTML(request) {
  const statusLabel = request.status === 'Zatwierdzony' ? '‚òë Zatwierdzam wniosek' : '‚òê Zatwierdzam wniosek';
  const statusReject = request.status === 'Odrzucony' ? '‚òë Odmawiam udzielenia urlopu' : '‚òê Odmawiam udzielenia urlopu';
  
  // Mapowanie typu na podstawƒô prawnƒÖ
  let legalBasis = 'Art. 1891 Kodeksu Pracy - urlop okoliczno≈õciowy';
  let daysInfo = '';
  
  if (request.type.includes('≈ölub w≈Çasny')) {
    daysInfo = '2 dni - ≈õlub w≈Çasny pracownika';
  } else if (request.type.includes('≈ölub dziecka')) {
    daysInfo = '1 dzie≈Ñ - ≈õlub dziecka pracownika';
  } else if (request.type.includes('Narodziny')) {
    daysInfo = '2 dni - narodziny dziecka pracownika';
  } else if (request.type.includes('ma≈Ç≈ºonka') || request.type.includes('dziecka') || request.type.includes('rodzica')) {
    daysInfo = '2 dni - zgon i pogrzeb ma≈Ç≈ºonka, dziecka, rodzica, ojczyma, macochy';
  } else if (request.type.includes('rodze≈Ñstwa') || request.type.includes('te≈õci√≥w') || request.type.includes('dziadk√≥w')) {
    daysInfo = '1 dzie≈Ñ - zgon i pogrzeb rodze≈Ñstwa, te≈õci√≥w, dziadk√≥w, lub innej osoby pozostajƒÖcej na utrzymaniu pracownika';
  }
  
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    @page {
      size: A4;
      margin: 1.5cm;
    }
    body {
      font-family: Arial, sans-serif;
      font-size: 10pt;
      line-height: 1.3;
      color: #000;
      margin: 0;
      padding: 0;
    }
    .header {
      text-align: center;
      font-size: 13pt;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 8px;
      border: 2px solid #000;
      background-color: #f3e5f5;
    }
    .section {
      margin-bottom: 12px;
    }
    .field {
      margin: 4px 0;
      padding-left: 10px;
      font-size: 9.5pt;
    }
    .field-label {
      font-weight: bold;
      display: inline-block;
      width: 180px;
    }
    .box {
      border: 1px solid #000;
      padding: 10px;
      margin: 10px 0;
      background-color: #f9f9f9;
    }
    .signature-section {
      margin-top: 20px;
      border-top: 2px solid #000;
      padding-top: 12px;
    }
    .signature-box {
      display: inline-block;
      width: 48%;
      text-align: center;
      vertical-align: top;
    }
    .signature-line {
      border-bottom: 1px solid #000;
      height: 35px;
      margin-bottom: 4px;
    }
    .footer {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #ccc;
      font-size: 8pt;
      color: #666;
      text-align: center;
    }
    .decision-box {
      border: 2px solid #000;
      padding: 10px;
      margin: 12px 0;
      background-color: #fff;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 9.5pt;
    }
    table td {
      padding: 4px 6px;
      border: 1px solid #999;
    }
    table td.label {
      font-weight: bold;
      width: 180px;
      background-color: #f3e5f5;
    }
    .compact {
      margin: 6px 0;
      font-size: 9pt;
    }
    .legal-basis {
      font-size: 8pt;
      color: #555;
      font-style: italic;
      margin-top: 8px;
      padding: 5px;
      background-color: #fce4ec;
      border-left: 3px solid #9c27b0;
    }
    .event-type {
      background-color: #f3e5f5;
      padding: 8px;
      margin: 8px 0;
      border-radius: 4px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div class="header">
  WNIOSEK O UDZIELENIE URLOPU OKOLICZNO≈öCIOWEGO
</div>

<div class="section">
  <div class="field">
    <span class="field-label">Imiƒô i nazwisko:</span>
    <span class="field-value"><strong>${request.name}</strong></span>
  </div>
  <div class="field">
    <span class="field-label">Login:</span>
    <span class="field-value">${request.login}</span>
  </div>
  <div class="field">
    <span class="field-label">Data z≈Ço≈ºenia wniosku:</span>
    <span class="field-value">${request.dateSubmitted}</span>
  </div>
</div>

<div class="box">
  <div style="font-weight: bold; margin-bottom: 8px;">Proszƒô o udzielenie urlopu okoliczno≈õciowego:</div>
  
  <div class="event-type">
    üéä ${request.type}
  </div>
  
  <table>
    <tr>
      <td class="label">Od dnia:</td>
      <td><strong>${request.dateFrom}</strong></td>
    </tr>
    <tr>
      <td class="label">Do dnia:</td>
      <td><strong>${request.dateTo}</strong></td>
    </tr>
    <tr>
      <td class="label">Liczba dni:</td>
      <td><strong>${request.days} ${request.days === 1 ? 'dzie≈Ñ' : 'dni'}</strong></td>
    </tr>
  </table>
  
  ${request.note ? `
  <div class="compact">
    <strong>Dodatkowe informacje:</strong> <em>${request.note}</em>
  </div>
  ` : ''}
  
  <div class="legal-basis">
    <strong>Podstawa prawna:</strong> ${legalBasis}<br>
    ${daysInfo ? `<strong>Wymiar:</strong> ${daysInfo}` : ''}
  </div>
</div>

<div class="section" style="margin-top: 15px; font-size: 9pt; color: #666;">
  <strong>Informacja:</strong> Pracownik jest zobowiƒÖzany do przedstawienia dokumentu potwierdzajƒÖcego 
  okoliczno≈õƒá uzasadniajƒÖcƒÖ udzielenie urlopu (np. akt ≈õlubu, akt urodzenia, akt zgonu).
</div>

<div class="signature-section">
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracownika</div>
  </div>
  
  <div class="signature-box">
    <div class="signature-line"></div>
    <div style="font-size: 9pt;">Data i podpis pracodawcy</div>
  </div>
</div>

${request.status !== 'OczekujƒÖcy' ? `
<div class="decision-box">
  <div style="font-weight: bold; margin-bottom: 8px;">Decyzja pracodawcy:</div>
  
  <div class="compact">
    ${statusLabel}
  </div>
  <div class="compact">
    ${statusReject}
  </div>
  
  ${request.managerComment ? `
  <div class="compact" style="margin-top: 8px;">
    <strong>Uwagi kierownika:</strong> <em>${request.managerComment}</em>
  </div>
  ` : ''}
  
  ${request.dateDecision ? `
  <div class="compact">
    <strong>Data decyzji:</strong> ${request.dateDecision}
  </div>
  ` : ''}
</div>
` : ''}

<div class="footer">
  Wniosek nr: ${request.id} | Wygenerowano: ${Utilities.formatDate(new Date(), 'Europe/Warsaw', 'yyyy-MM-dd HH:mm')}<br>
  System Magazynowy - Rejestrator Czasu Pracy
</div>

</body>
</html>
  `;
  
  return html;
}

/**
 * Pobiera WSZYSTKIE wnioski pracownika (urlopy, dni wolne, okoliczno≈õciowe, plany)
 * Do wy≈õwietlenia w g≈Ç√≥wnym widoku "Planowanie nieobecno≈õci"
 */
function getUserAllAbsenceHistory(login) {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE CA≈ÅEJ HISTORII NIEOBECNO≈öCI DLA:', login, '===');
  
  const allRequests = [];
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    
    // 1. Urlopy wypoczynkowe
    const vacationSheet = ss.getSheetByName(VACATION_SHEETS.REQUESTS);
    if (vacationSheet && vacationSheet.getLastRow() > 1) {
      const data = vacationSheet.getRange(2, 1, vacationSheet.getLastRow() - 1, 12).getValues();
      data.forEach(row => {
        if (row[1] === login) {
          allRequests.push({
            id: row[0],
            type: 'vacation',
            typeIcon: 'üèñÔ∏è',
            typeName: 'Urlop wypoczynkowy',
            dateFrom: formatDate(row[4]),
            dateTo: formatDate(row[5]),
            days: row[6],
            status: row[7],
            dateSubmitted: formatDate(row[3]),
            details: row[8] || 'Planowany'
          });
        }
      });
    }
    
    // 2. Dni wolne
    const dayOffSheet = ss.getSheetByName('Dni_wolne');
    if (dayOffSheet && dayOffSheet.getLastRow() > 1) {
      const data = dayOffSheet.getRange(2, 1, dayOffSheet.getLastRow() - 1, 12).getValues();
      data.forEach(row => {
        if (row[1] === login) {
          allRequests.push({
            id: row[0],
            type: 'dayoff',
            typeIcon: 'üìÖ',
            typeName: 'Dzie≈Ñ wolny',
            dateFrom: formatDate(row[4]),
            dateTo: formatDate(row[4]),  // Ten sam dzie≈Ñ
            days: 1,
            status: row[9],
            dateSubmitted: formatDate(row[3]),
            details: row[5]  // Typ dnia wolnego
          });
        }
      });
    }
    
    // 3. Urlopy okoliczno≈õciowe
    const occasionalSheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    if (occasionalSheet && occasionalSheet.getLastRow() > 1) {
      const data = occasionalSheet.getRange(2, 1, occasionalSheet.getLastRow() - 1, 12).getValues();
      data.forEach(row => {
        if (row[1] === login) {
          allRequests.push({
            id: row[0],
            type: 'occasional',
            typeIcon: 'üéä',
            typeName: 'Urlop okoliczno≈õciowy',
            dateFrom: formatDate(row[4]),
            dateTo: formatDate(row[5]),
            days: row[6],
            status: row[9],
            dateSubmitted: formatDate(row[3]),
            details: row[7]  // Typ wydarzenia
          });
        }
      });
    }
    
    // 4. Plany roczne
    const yearPlanSheet = ss.getSheetByName('Plan_roczny');
    if (yearPlanSheet && yearPlanSheet.getLastRow() > 1) {
      const data = yearPlanSheet.getRange(2, 1, yearPlanSheet.getLastRow() - 1, 10).getValues();
      data.forEach(row => {
        if (row[1] === login) {
          allRequests.push({
            id: row[0],
            type: 'yearplan',
            typeIcon: 'üìÜ',
            typeName: 'Plan roczny',
            dateFrom: row[4] + '-01-01',  // Rok
            dateTo: row[4] + '-12-31',
            days: row[5],
            status: row[7],
            dateSubmitted: formatDate(row[3]),
            details: 'Rok ' + row[4]
          });
        }
      });
    }
    
    // Sortuj: najnowsze pierwsze (po dacie z≈Ço≈ºenia)
    allRequests.sort((a, b) => {
      const dateA = new Date(a.dateSubmitted);
      const dateB = new Date(b.dateSubmitted);
      return dateB - dateA;
    });
    
    console.log('‚úÖ Znaleziono ≈ÇƒÖcznie wniosk√≥w:', allRequests.length);
    return allRequests;
    
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd getUserAllAbsenceHistory:', error);
    return [];
  }
}

/**
 * Pobiera wnioski o dzie≈Ñ wolny dla danego pracownika
 * @param {string} login - Login pracownika
 * @returns {Array} - Lista wniosk√≥w
 */
function getDayOffRequests(login) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Dni_wolne');
    
    if (!sheet) {
      console.log('Arkusz Dni_wolne nie istnieje');
      return [];
    }
    
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return []; // Tylko nag≈Ç√≥wki lub pusty
    }
    
    const headers = data[0];
    const requests = [];
    
    // Znajd≈∫ indeksy kolumn
    const colIndex = {
      id: headers.indexOf('ID'),
      login: headers.indexOf('Login'),
      name: headers.indexOf('Imiƒô i nazwisko'),
      type: headers.indexOf('Typ'),
      date: headers.indexOf('Data'),
      timeFrom: headers.indexOf('Godzina od'),
      timeTo: headers.indexOf('Godzina do'),
      reason: headers.indexOf('Pow√≥d'),
      status: headers.indexOf('Status'),
      dateSubmitted: headers.indexOf('Data z≈Ço≈ºenia'),
      managerComment: headers.indexOf('Komentarz kierownika')
    };
    
    console.log('Kolumny Dni_wolne:', colIndex);
    
    // Przetw√≥rz wiersze
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowLogin = colIndex.login >= 0 ? row[colIndex.login] : '';
      
      if (rowLogin === login) {
        const request = {
          id: colIndex.id >= 0 ? row[colIndex.id] : i,
          login: rowLogin,
          name: colIndex.name >= 0 ? row[colIndex.name] : '',
          type: colIndex.type >= 0 ? row[colIndex.type] : '',
          date: colIndex.date >= 0 ? formatDateForDisplay(row[colIndex.date]) : '',
          timeFrom: colIndex.timeFrom >= 0 ? row[colIndex.timeFrom] : '',
          timeTo: colIndex.timeTo >= 0 ? row[colIndex.timeTo] : '',
          reason: colIndex.reason >= 0 ? row[colIndex.reason] : '',
          status: colIndex.status >= 0 ? row[colIndex.status] : 'OczekujƒÖcy',
          dateSubmitted: colIndex.dateSubmitted >= 0 ? formatDateForDisplay(row[colIndex.dateSubmitted]) : '',
          managerComment: colIndex.managerComment >= 0 ? row[colIndex.managerComment] : ''
        };
        
        requests.push(request);
      }
    }
    
    // Sortuj od najnowszych
    requests.sort((a, b) => {
      return new Date(b.dateSubmitted) - new Date(a.dateSubmitted);
    });
    
    console.log('Znaleziono wniosk√≥w o dzie≈Ñ wolny dla ' + login + ':', requests.length);
    return requests;
    
  } catch (error) {
    console.error('B≈ÇƒÖd getDayOffRequests:', error);
    return [];
  }
}

/**
 * Pomocnicza funkcja do formatowania daty
 */
function formatDateForDisplay(date) {
  if (!date) return '';
  
  if (date instanceof Date) {
    return Utilities.formatDate(date, 'Europe/Warsaw', 'yyyy-MM-dd');
  }
  
  return String(date);
}

/**
 * Pobiera wnioski o urlop okoliczno≈õciowy dla danego pracownika
 * @param {string} login - Login pracownika
 * @returns {Array} - Lista wniosk√≥w
 */
function getOccasionalLeaveRequests(login) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Urlopy_okolicznosciowe');
    
    if (!sheet) {
      console.log('Arkusz Urlopy_okolicznosciowe nie istnieje');
      return [];
    }
    
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return [];
    }
    
    const headers = data[0];
    const requests = [];
    
    // Znajd≈∫ indeksy kolumn
    const colIndex = {
      id: headers.indexOf('ID'),
      login: headers.indexOf('Login'),
      name: headers.indexOf('Imiƒô i nazwisko'),
      type: headers.indexOf('Typ'),
      dateFrom: headers.indexOf('Data od'),
      dateTo: headers.indexOf('Data do'),
      days: headers.indexOf('Dni'),
      note: headers.indexOf('Notatka'),
      status: headers.indexOf('Status'),
      dateSubmitted: headers.indexOf('Data z≈Ço≈ºenia'),
      managerComment: headers.indexOf('Komentarz kierownika')
    };
    
    console.log('Kolumny Urlopy_okolicznosciowe:', colIndex);
    
    // Przetw√≥rz wiersze
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowLogin = colIndex.login >= 0 ? row[colIndex.login] : '';
      
      if (rowLogin === login) {
        const request = {
          id: colIndex.id >= 0 ? row[colIndex.id] : i,
          login: rowLogin,
          name: colIndex.name >= 0 ? row[colIndex.name] : '',
          type: colIndex.type >= 0 ? row[colIndex.type] : '',
          dateFrom: colIndex.dateFrom >= 0 ? formatDateForDisplay(row[colIndex.dateFrom]) : '',
          dateTo: colIndex.dateTo >= 0 ? formatDateForDisplay(row[colIndex.dateTo]) : '',
          days: colIndex.days >= 0 ? row[colIndex.days] : 1,
          note: colIndex.note >= 0 ? row[colIndex.note] : '',
          status: colIndex.status >= 0 ? row[colIndex.status] : 'OczekujƒÖcy',
          dateSubmitted: colIndex.dateSubmitted >= 0 ? formatDateForDisplay(row[colIndex.dateSubmitted]) : '',
          managerComment: colIndex.managerComment >= 0 ? row[colIndex.managerComment] : ''
        };
        
        requests.push(request);
      }
    }
    
    // Sortuj od najnowszych
    requests.sort((a, b) => {
      return new Date(b.dateSubmitted) - new Date(a.dateSubmitted);
    });
    
    console.log('Znaleziono wniosk√≥w okoliczno≈õciowych dla ' + login + ':', requests.length);
    return requests;
    
  } catch (error) {
    console.error('B≈ÇƒÖd getOccasionalLeaveRequests:', error);
    return [];
  }
}

/**
 * Pobiera zaplanowane daty urlopowe dla pracownika na dany rok
 * Zwraca mapƒô data -> status (OczekujƒÖcy/Zatwierdzony/Odrzucony)
 */
function getYearPlanDatesForCalendar(login, year) {
  sprawdzUprawnienia();
  console.log('=== POBIERANIE DAT PLANU ROCZNEGO ===');
  console.log('Login:', login, 'Rok:', year);
  
  const result = {
    planned: [],    // OczekujƒÖcy - zielone
    approved: [],   // Zatwierdzony - niebieskie
    rejected: []    // Odrzucony - czerwone
  };
  
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName('Plan_roczny');
    
    if (!sheet || sheet.getLastRow() <= 1) {
      console.log('Brak danych w arkuszu Plan_roczny');
      return result;
    }
    
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 10).getValues();
    
    data.forEach(row => {
      // A=ID, B=Login, C=Imie_Nazwisko, D=Data_zlozenia, E=Rok, F=Liczba_dni,
      // G=Lista_dat, H=Status, I=Data_decyzji, J=Komentarz_kierownika
      const rowLogin = row[1];
      const rowYear = row[4];
      const datesJson = row[6];
      const status = row[7];
      
      if (rowLogin !== login) return;
      if (rowYear != year) return;  // != ≈ºeby por√≥wnaƒá string z number
      
      let dates = [];
      try {
        dates = typeof datesJson === 'string' ? JSON.parse(datesJson) : datesJson;
        if (!Array.isArray(dates)) dates = [];
      } catch (e) {
        console.log('B≈ÇƒÖd parsowania dat:', e);
        dates = [];
      }
      
      console.log('Znaleziono plan:', status, 'z', dates.length, 'datami');
      
      // Przypisz daty do odpowiedniej kategorii
      if (status === 'OczekujƒÖcy') {
        result.planned = result.planned.concat(dates);
      } else if (status === 'Zatwierdzony' || status === 'Czƒô≈õciowo zatwierdzony') {
        result.approved = result.approved.concat(dates);
      } else if (status === 'Odrzucony') {
        result.rejected = result.rejected.concat(dates);
      }
    });
    
    // Usu≈Ñ duplikaty
    result.planned = [...new Set(result.planned)];
    result.approved = [...new Set(result.approved)];
    result.rejected = [...new Set(result.rejected)];
    
    console.log('Wynik - OczekujƒÖce:', result.planned.length, 
                'Zatwierdzone:', result.approved.length, 
                'Odrzucone:', result.rejected.length);
    
    return result;
    
  } catch (error) {
    console.error('B≈ÇƒÖd getYearPlanDatesForCalendar:', error);
    return result;
  }
}

/**
 * Tworzy trigger czasowy dla aktualizacji podsumowania nieobecno≈õci
 * Uruchom tƒô funkcjƒô RAZ rƒôcznie, ≈ºeby utworzyƒá trigger
 */
function createAbsenceSummaryTrigger() {
  // Usu≈Ñ istniejƒÖce triggery dla tej funkcji (≈ºeby nie duplikowaƒá)
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'updateAbsenceSummary') {
      ScriptApp.deleteTrigger(trigger);
      console.log('Usuniƒôto stary trigger');
    }
  });
  
  // Utw√≥rz nowy trigger - codziennie o 6:00
  ScriptApp.newTrigger('updateAbsenceSummary')
    .timeBased()
    .everyDays(1)
    .atHour(6)
    .create();
  
  console.log('‚úÖ Utworzono trigger: updateAbsenceSummary codziennie o 6:00');
}

/**
 * Usuwa trigger dla podsumowania nieobecno≈õci
 */
function removeAbsenceSummaryTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  let removed = 0;
  
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'updateAbsenceSummary') {
      ScriptApp.deleteTrigger(trigger);
      removed++;
    }
  });
  
  console.log(`Usuniƒôto ${removed} trigger√≥w dla updateAbsenceSummary`);
}

/**
 * Pobiera listƒô aktywnych pracownik√≥w (pracujƒÖcych i na przerwie)
 * Dostƒôpne bez logowania - do wy≈õwietlenia "Kto jest na magazynie"
 */
/**
 * Pobiera listƒô aktywnych pracownik√≥w (kto jest na magazynie)
 */
function getActiveEmployees() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName('Pracownicy');
    const logsSheet = ss.getSheetByName('Logi_czasowe');

    if (!usersSheet) return { success: false, message: 'Nie znaleziono arkusza Pracownicy' };

    const data = usersSheet.getDataRange().getValues();
    const headers = data[0];

    const colIndex = {
      login: 0, // kolumna A
      imie_nazwisko: headers.indexOf('imie_nazwisko'),
      dzial: headers.indexOf('dzial'),
      status: headers.indexOf('Status'),
      godz_start: headers.indexOf('Godz_start')
    };

    if (colIndex.imie_nazwisko === -1 || colIndex.status === -1) {
      return { success: false, message: 'Nie znaleziono wymaganych kolumn' };
    }

    // 1) Zbierz aktywnych + zapamiƒôtaj kt√≥rym brakuje dzia≈Çu
    const working = [];
    const onBreak = [];
    let absentCount = 0;

    const needDept = new Set();

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const login = row[colIndex.login];
      const name = row[colIndex.imie_nazwisko];
      const operationFromUser = (colIndex.dzial >= 0 ? row[colIndex.dzial] : '') || '';
      const status = row[colIndex.status] || '';
      const startTime = (colIndex.godz_start >= 0 ? row[colIndex.godz_start] : '');

      if (!name || !login) continue;

      let formattedTime = '';
      if (startTime) {
        if (startTime instanceof Date) formattedTime = Utilities.formatDate(startTime, 'Europe/Warsaw', 'HH:mm');
        else formattedTime = startTime.toString();
      }

      const employee = {
        login: String(login),
        name: String(name),
        operation: String(operationFromUser || ''),
        startTime: formattedTime
      };

      if (status === 'Pracuje') {
        working.push(employee);
        if (!employee.operation) needDept.add(employee.login);
      } else if (status === 'Na przerwie') {
        onBreak.push(employee);
        if (!employee.operation) needDept.add(employee.login);
      } else {
        absentCount++;
      }
    }

    // 2) Je≈õli brakuje dzia≈Çu ‚Äì dociƒÖgnij z Logi_czasowe (ostatni wpis dla loginu)
if (logsSheet && needDept.size > 0) {
  const logs = logsSheet.getDataRange().getValues();
  if (logs.length > 1) {
    // nag≈Ç√≥wki log√≥w (normalizacja)
    const logHeaders = logs[0].map(h => String(h || '').trim());

    const findIdx = (candidates) => {
      const lower = logHeaders.map(x => x.toLowerCase());
      for (const name of candidates) {
        const idx = lower.indexOf(name.toLowerCase());
        if (idx !== -1) return idx;
      }
      return -1;
    };

    const liLogin = findIdx(['login', 'Login']);
    const liDzial = findIdx(['dzial', 'dzia≈Ç', 'Dzia≈Ç']);

    if (liLogin !== -1 && liDzial !== -1) {
      const lastDeptByLogin = {};

      // od ko≈Ñca: pierwszy znaleziony wpis = najnowszy
      for (let i = logs.length - 1; i >= 1; i--) {
        const r = logs[i];
        const l = r[liLogin];
        if (!l) continue;

        const key = String(l).trim();
        if (!needDept.has(key)) continue;
        if (lastDeptByLogin[key]) continue;

        const d = r[liDzial];
        if (d) lastDeptByLogin[key] = String(d).trim();

        // je≈õli ju≈º mamy dla wszystkich, mo≈ºna przerwaƒá
        if (Object.keys(lastDeptByLogin).length === needDept.size) break;
      }

      // wstrzyknij brakujƒÖce dzia≈Çy
      working.forEach(e => {
        if (!e.operation && lastDeptByLogin[e.login]) e.operation = lastDeptByLogin[e.login];
      });
      onBreak.forEach(e => {
        if (!e.operation && lastDeptByLogin[e.login]) e.operation = lastDeptByLogin[e.login];
      });
    }
  }
}

    return {
      success: true,
      working: working,
      onBreak: onBreak,
      absentCount: absentCount,
      timestamp: Utilities.formatDate(new Date(), 'Europe/Warsaw', 'HH:mm:ss')
    };

  } catch (error) {
    return { success: false, message: error.toString(), working: [], onBreak: [], absentCount: 0 };
  }
}

// ===== PODGLƒÑD LIVE (KROK 4) =====

function getWorkforceLiveSnapshot() {
  sprawdzUprawnienia();

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const userSheet = ss.getSheetByName(SHEETS.USERS);     // Pracownicy
  const logsSheet = ss.getSheetByName(SHEETS.LOGS);      // Logi_czasowe

  if (!userSheet) throw new Error('Brak arkusza: ' + SHEETS.USERS);
  if (!logsSheet) throw new Error('Brak arkusza: ' + SHEETS.LOGS);

  const tz = 'Europe/Warsaw';
  const now = new Date();
  const todayStr = Utilities.formatDate(now, tz, 'yyyy-MM-dd');

  // 1 minuta ‚Äì zgodnie z ustaleniem
  const ABSENT_BUFFER_MIN = 1;
  const LATE_BUFFER_MIN = 1;

  // Pobierz usprawiedliwienia na dzi≈õ (≈ºeby nie by≈Ço fa≈Çszywych alarm√≥w)
  const vacations = getVacationHistoryRange(todayStr, todayStr) || [];
  const l4List = getL4HistoryRange(todayStr, todayStr) || [];
  const dayOffList = getDayOffHistoryRange(todayStr, todayStr) || [];
  const occasionalList = getOccasionalLeaveHistoryRange(todayStr, todayStr) || [];

  const justifiedMap = new Map(); // login -> {type, label}
  vacations.forEach(v => justifiedMap.set(v.login, { 
  type: 'vacation', 
  label: 'Urlop',
  from: v.dateFrom,
  to: v.dateTo
}));

l4List.forEach(v => justifiedMap.set(v.login, { 
  type: 'l4', 
  label: 'L4',
  from: v.dateFrom,
  to: v.dateTo
}));

dayOffList.forEach(v => justifiedMap.set(v.login, { 
  type: 'dayoff', 
  label: 'Dzie≈Ñ wolny',
  from: v.dateFrom,
  to: v.dateTo
}));

occasionalList.forEach(v => justifiedMap.set(v.login, { 
  type: 'occasional', 
  label: 'Okoliczno≈õciowy',
  from: v.dateFrom,
  to: v.dateTo
}));

  // Wczytaj pracownik√≥w
  const userData = userSheet.getDataRange().getValues();
  const headers = userData[0].map(h => String(h || '').trim());
  const norm = (s) => String(s || '')
  .trim()
  .toLowerCase()
  .replace(/≈Ç/g, 'l')
  .normalize('NFD')
  .replace(/[\u0300-\u036f]/g, '');

  const idxLogin = headers.findIndex(h => norm(h) === 'login');
  const idxName = headers.findIndex(h => norm(h).includes('imie') || norm(h).includes('nazw'));
  const idxDept  = headers.findIndex(h => norm(h).includes('dzial'));
  const idxStatus = headers.findIndex(h => norm(h) === 'status');
  const idxStart = headers.findIndex(h => String(h || '').trim() === 'Godz_start');
  const idxEnd   = headers.findIndex(h => String(h || '').trim() === 'Godz_koniec');

  if (idxLogin === -1) throw new Error('Brak kolumny login w Pracownicy');
  if (idxName === -1) throw new Error('Brak kolumny imiƒô/nazwisko w Pracownicy');
  if (idxDept === -1) throw new Error('Brak kolumny dzia≈Ç w Pracownicy');
  if (idxStatus === -1) throw new Error('Brak kolumny Status w Pracownicy');
  if (idxStart === -1) throw new Error('Brak kolumny Godz_start w Pracownicy');
  if (idxEnd === -1) throw new Error('Brak kolumny Godz_koniec w Pracownicy');

  const workers = [];
  for (let i = 1; i < userData.length; i++) {
    const login = String(userData[i][idxLogin] || '').trim();
    if (!login) continue;

    workers.push({
      login,
      name: String(userData[i][idxName] || '').trim(),
      baseDept: String(userData[i][idxDept] || '').trim(),
      sheetStatus: String(userData[i][idxStatus] || '').trim(),
      startTime: String(userData[i][idxStart] || '').trim(), // "06:00"
      endTime: String(userData[i][idxEnd] || '').trim()      // "14:00"
    });
  }

  // Wczytaj logi z dzi≈õ
  const logsData = logsSheet.getDataRange().getValues();
  const logHeaders = logsData[0].map(h => String(h || '').trim());

  // typowe indeksy w DBK:
  // [1] timestamp, [2] login, [4] department, [5] action, [6] status
  const lIdxLogin = logHeaders.findIndex(h => h.toLowerCase() === 'login');
  const lIdxDept = logHeaders.findIndex(h => norm(h).includes('dzial'));
  const lIdxAction = logHeaders.findIndex(h => h.toLowerCase().includes('akc') || h.toLowerCase().includes('action') || h.toLowerCase().includes('operac'));
  const lIdxStatus = logHeaders.findIndex(h => h.toLowerCase().includes('status'));

    if (lIdxLogin === -1) throw new Error('Nie mogƒô rozpoznaƒá kolumny login w Logi_czasowe');

  // üîß U Ciebie jest kolumna "timestamp" jako ID (187,188...), a prawdziwy datetime jest w kolumnie "czas"
  // Dlatego wymuszamy wyb√≥r w≈Ça≈õciwej kolumny czasu:
  const lower = (x) => String(x || '').trim().toLowerCase();

  let lIdxRealTs = logHeaders.findIndex(h => lower(h) === 'czas');
  if (lIdxRealTs === -1) lIdxRealTs = logHeaders.findIndex(h => lower(h).includes('czas'));
  if (lIdxRealTs === -1) lIdxRealTs = logHeaders.findIndex(h => lower(h).includes('data') || lower(h).includes('timestamp'));
  if (lIdxRealTs === -1) throw new Error('Nie mogƒô rozpoznaƒá kolumny czasu (czas/data) w Logi_czasowe');

  const logsTodayByLogin = new Map(); // login -> [{timestamp, department, action, status}]

  const parseLogTs = (v) => {
    if (v instanceof Date) return v;

    const s = String(v || '').trim();
    if (!s) return null;

    // Najczƒôstszy format w DBK: "yyyy-MM-dd HH:mm:ss"
    if (/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}$/.test(s)) {
      try {
        return Utilities.parseDate(s, tz, 'yyyy-MM-dd HH:mm:ss');
      } catch (e) {
        return null;
      }
    }

    // Awaryjnie: spr√≥buj wprost
    const d = new Date(s);
    return isNaN(d) ? null : d;
  };

  for (let i = 1; i < logsData.length; i++) {
    const ts = parseLogTs(logsData[i][lIdxRealTs]);
    if (!ts) continue;

    const dStr = Utilities.formatDate(ts, tz, 'yyyy-MM-dd');
    if (dStr !== todayStr) continue;

    const login = String(logsData[i][lIdxLogin] || '').trim();
    if (!login) continue;

    const entry = {
      timestamp: ts,
      department: lIdxDept !== -1 ? String(logsData[i][lIdxDept] || '').trim() : '',
      action: lIdxAction !== -1 ? String(logsData[i][lIdxAction] || '').trim() : '',
      status: lIdxStatus !== -1 ? String(logsData[i][lIdxStatus] || '').trim() : ''
    };

    if (!logsTodayByLogin.has(login)) logsTodayByLogin.set(login, []);
    logsTodayByLogin.get(login).push(entry);
  }

  // helpery
  const parseHHMM = (hhmm) => {
    const m = String(hhmm || '').trim().match(/^(\d{1,2}):(\d{2})$/);
    if (!m) return null;
    const h = Number(m[1]);
    const min = Number(m[2]);
    if (!(h >= 0 && h <= 23 && min >= 0 && min <= 59)) return null;
    return { h, min };
  };

  const toDateAt = (baseDate, hhmm) => {
    const t = parseHHMM(hhmm);
    if (!t) return null;
    const d = new Date(baseDate);
    d.setHours(t.h, t.min, 0, 0);
    return d;
  };

  const fmtHM = (d) => Utilities.formatDate(d, tz, 'HH:mm');

  const diffMin = (a, b) => Math.floor((a - b) / 60000);

  const calcTotalBreakMinutes = (logs) => {
  let total = 0;
  let breakStart = null;

  logs.forEach(l => {
    const a = norm(l.action);
    const s = norm(l.status);

    // start przerwy
    if (a.includes('wychodze na przerwe') || s === 'na przerwie') {
      if (!breakStart) breakStart = l.timestamp;
      return;
    }

    // koniec przerwy (powr√≥t)
    if (a.includes('wracam z przerwy') || a.includes('wracam z przerwe')) {
      if (breakStart) {
        total += Math.max(0, diffMin(l.timestamp, breakStart));
        breakStart = null;
      }
      return;
    }

    // je≈õli kto≈õ wyszed≈Ç z pracy bƒôdƒÖc na przerwie ‚Äì domknij przerwƒô do STOP
    if (breakStart && (a.includes('wychodze z pracy') || s === 'nieaktywny')) {
      total += Math.max(0, diffMin(l.timestamp, breakStart));
      breakStart = null;
      return;
    }
  });

  // je≈õli nadal na przerwie ‚Äì licz do "teraz"
  const last = logs[logs.length - 1];
  if (breakStart && last) {
    const lastA = norm(last.action);
    const lastS = norm(last.status);

    if (lastS === 'na przerwie' || lastA.includes('wychodze na przerwe')) {
      total += Math.max(0, diffMin(now, breakStart));
    }
  }

  return total;
};

  const firstEntryFromLogs = (logs) => {
  // pierwszy moment, gdy status zmieni≈Ç siƒô na "Pracuje" (najpewniejsze)
  const first = logs.find(l => norm(l.status) === 'pracuje');
  return first ? first.timestamp : null;
};

  const lastActivityFromLogs = (logs) => {
    const last = logs[logs.length - 1];
    if (!last) return null;
    return { time: fmtHM(last.timestamp), action: last.action || last.status || '' };
  };

  const lastDeptFromLogs = (logs) => {
    const last = logs[logs.length - 1];
    return last ? (last.department || '') : '';
  };

  // budujemy wynik
  const rows = [];
  let cntWorking = 0, cntBreak = 0, cntLate = 0, cntAbsent = 0;

  workers.forEach(w => {
    const logs = logsTodayByLogin.get(w.login) || [];
    const firstEntry = firstEntryFromLogs(logs);
    const lastAct = lastActivityFromLogs(logs);

    const deptNow = (lastDeptFromLogs(logs) || w.baseDept || '-').trim();
    const shiftStr = (w.startTime && w.endTime) ? `${w.startTime}-${w.endTime}` : '-';

    const plannedStart = toDateAt(now, w.startTime);
    const plannedStartPlusAbsent = plannedStart ? new Date(plannedStart.getTime() + ABSENT_BUFFER_MIN * 60000) : null;

    const justified = justifiedMap.get(w.login) || null;

    let status = 'NIEAKTYWNY';
    let alertType = '';
    let alertText = '';
    let lateMinutes = 0;

    // ===== STATUS z log√≥w (wa≈ºniejsze ni≈º arkusz) =====
const last = logs.length ? logs[logs.length - 1] : null;
const lastActionNorm = last ? norm(last.action) : '';
const lastStatusNorm = last ? norm(last.status) : '';

const hasEntry = !!firstEntry;

// czy ju≈º wyszed≈Ç z pracy?
const hasExitNow =
  !!last &&
  (lastActionNorm.includes('wychodze z pracy') || lastStatusNorm === 'nieaktywny');

// czy jest na przerwie?
const isBreakNow =
  !!last &&
  (lastActionNorm.includes('wychodze na przerwe') || lastStatusNorm === 'na przerwie');

// timestamp STOP (ostatnie wyj≈õcie)
let stopTs = null;
if (logs.length) {
  for (let i = logs.length - 1; i >= 0; i--) {
    const a = norm(logs[i].action);
    const s = norm(logs[i].status);
    if (a.includes('wychodze z pracy') || s === 'nieaktywny') {
      stopTs = logs[i].timestamp;
      break;
    }
  }
}

// Czas przerw dzi≈õ (dzia≈Ça dla aktywnych i nieaktywnych)
const breakMin = logs.length ? calcTotalBreakMinutes(logs) : 0;
const breakInfo = `Przerwa: ${breakMin}m`;

// helper do formatowania minut -> "Xh Ym"
const fmtDur = (mins) => {
  const m = Math.max(0, Math.floor(mins));
  const h = Math.floor(m / 60);
  const r = m % 60;
  return `${h}h ${r}m`;
};

let workInfo = ''; // np. "Praca: 7h 12m"

// 1) status wynikowy
status = 'NIEAKTYWNY';

// je≈õli ma usprawiedliwienie (i brak wej≈õcia) ‚Äî poka≈º jako nieaktywny, ale info bƒôdzie z uspraw.
if (!hasEntry && justified) {
  status = 'NIEAKTYWNY';
}

// je≈õli ma wej≈õcie i NIE ma wyj≈õcia -> pracuje/przerwa
if (hasEntry && !hasExitNow) {
  status = isBreakNow ? 'PRZERWA' : 'PRACUJE';
}

// je≈õli ma wej≈õcie i ma wyj≈õcie -> NIEAKTYWNY (to by≈Ç Tw√≥j bug)
if (hasEntry && hasExitNow) {
  status = 'NIEAKTYWNY';
}

// 2) pre-start (tylko jak brak wej≈õcia i brak uspraw.)
if ((status === 'NIEAKTYWNY') && plannedStart && now < plannedStart && !hasEntry && !justified) {
  status = `START O ${w.startTime}`;
}

// 3) brak wej≈õcia po planie -> NIEOBECNO≈öƒÜ (po +1 min) je≈õli nieusprawiedliwione
if ((status === 'NIEAKTYWNY') && plannedStartPlusAbsent && now >= plannedStartPlusAbsent && !hasEntry && !justified) {
  status = 'NIEOBECNO≈öƒÜ';
  alertType = 'ABSENT';
  alertText = '‚òÅ Nieobecno≈õƒá';
  cntAbsent++;
}

// 4) sp√≥≈∫nienie (ALERT), ale status dalej PRACUJE/PRZERWA/NIEAKTYWNY
if (plannedStart && firstEntry && diffMin(firstEntry, plannedStart) >= LATE_BUFFER_MIN) {
  const lateM = diffMin(firstEntry, plannedStart);
  lateMinutes = lateM;
  alertType = 'LATE';
  alertText = `‚òÅ Sp√≥≈∫nienie (${lateM} min)`;
  cntLate++;
}

// ===== INFO: Start/Trwa lub STOP =====
let startInfo = 'Brak wej≈õcia';

if (hasEntry && !hasExitNow) {
  const mins = Math.max(0, diffMin(now, firstEntry));
  startInfo = `Start: ${fmtHM(firstEntry)} ‚Ä¢ Trwa: ${fmtDur(mins)}`;
} else if (hasEntry && hasExitNow) {
  const stop = stopTs || last.timestamp;
  const totalSpan = Math.max(0, diffMin(stop, firstEntry));
  const netWork = Math.max(0, totalSpan - breakMin);

  workInfo = `Praca: ${fmtDur(netWork)}`;
  startInfo = `Start: ${fmtHM(firstEntry)} ‚Ä¢ Stop: ${fmtHM(stop)} ‚Ä¢ ${workInfo}`;
} else if (justified) {
  const fmt = (d) => d ? Utilities.formatDate(new Date(d), tz, 'dd.MM.yyyy') : '';
  const fromStr = fmt(justified.from);
  const toStr = fmt(justified.to);

  if (fromStr && toStr && fromStr !== toStr) {
    startInfo = `${justified.label} (${fromStr} ‚Äì ${toStr})`;
  } else if (fromStr) {
    startInfo = `${justified.label} (${fromStr})`;
  } else {
    startInfo = `${justified.label}`;
  }
} else if (plannedStart && now < plannedStart) {
  startInfo = `Start o ${w.startTime}`;
}

// liczniki (dopiero po ustaleniu statusu)
if (status === 'PRACUJE') cntWorking++;
if (status === 'PRZERWA') cntBreak++;

    rows.push({
      login: w.login,
      name: w.name || w.login,
      dept: deptNow || '-',
      shift: shiftStr,
      status: status,
      lateMinutes: lateMinutes,
      startInfo: startInfo,
      workInfo: workInfo,

      // ‚úÖ PRZERWY (≈ºeby nie by≈Ço undefined w szczeg√≥≈Çach)
      breakMinutes: breakMin,
      breakInfo: breakInfo,

      alertType: alertType,     // 'LATE' / 'ABSENT' / ''
      alertText: alertText,     // tekst do chmurki
      firstEntry: firstEntry ? fmtHM(firstEntry) : '',
      lastActivity: lastAct ? `${lastAct.time}${lastAct.action ? ' ‚Ä¢ ' + lastAct.action : ''}` : ''
    });
  });

  // sort: alerty na g√≥rze, potem alfabetycznie
  const prio = (r) => r.alertType === 'ABSENT' ? 0 : (r.alertType === 'LATE' ? 1 : 2);
  rows.sort((a, b) => {
    const pa = prio(a), pb = prio(b);
    if (pa !== pb) return pa - pb;
    return String(a.name).localeCompare(String(b.name), 'pl');
  });

  return {
    success: true,
    today: todayStr,
    summary: {
      working: cntWorking,
      break: cntBreak,
      late: cntLate,
      absent: cntAbsent
    },
    rows: rows
  };
}

// ===== SYSTEM OG≈ÅOSZE≈É =====

/**
 * Pobiera nieprzeczytane og≈Çoszenia dla pracownika
 */
function getUnreadAnnouncements(loginPracownika) {
  try {
    console.log('=== getUnreadAnnouncements START ===');
    console.log('Login pracownika:', loginPracownika);
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ogloszeniaSheet = ss.getSheetByName('Ogloszenia');
    const odczytySheet = ss.getSheetByName('Ogloszenia_odczyty');
    
    console.log('Arkusz Ogloszenia:', ogloszeniaSheet ? 'znaleziony' : 'BRAK');
    console.log('Arkusz Ogloszenia_odczyty:', odczytySheet ? 'znaleziony' : 'BRAK');
    
    if (!ogloszeniaSheet || !odczytySheet) {
      return { success: true, announcements: [] };
    }
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Pobierz wszystkie og≈Çoszenia
    const ogloszeniaData = ogloszeniaSheet.getDataRange().getValues();
    console.log('Liczba wierszy w Ogloszenia:', ogloszeniaData.length);
    console.log('Pierwszy wiersz danych:', ogloszeniaData[1]);
    if (ogloszeniaData.length <= 1) {
      return { success: true, announcements: [] };
    }
    
    // Pobierz odczyty tego pracownika
    const odczytyData = odczytySheet.getDataRange().getValues();
    const przeczytaneIds = [];
    
    for (let i = 1; i < odczytyData.length; i++) {
      if (odczytyData[i][1] === loginPracownika) {
        przeczytaneIds.push(odczytyData[i][0].toString());
      }
    }
    
    // Filtruj og≈Çoszenia
    const unread = [];
    
    for (let i = 1; i < ogloszeniaData.length; i++) {
      const row = ogloszeniaData[i];
      const id = row[0].toString();
      const dataWaznosci = new Date(row[2]);
      dataWaznosci.setHours(23, 59, 59, 999);
      const typ = row[3];
      const tresc = row[4];
      const autor = row[5];
      const odbiorcy = row[6] ? row[6].toString() : '';
      
      // Sprawd≈∫ czy og≈Çoszenie jest jeszcze wa≈ºne
      if (dataWaznosci < today) continue;
      
      // Sprawd≈∫ czy ju≈º przeczytane
      if (przeczytaneIds.includes(id)) continue;
      
      // Sprawd≈∫ czy pracownik jest odbiorcƒÖ
      const czyDlaWszystkich = odbiorcy.toUpperCase() === 'WSZYSCY';
      const czyDlaMnie = odbiorcy.toLowerCase().split(',').map(s => s.trim()).includes(loginPracownika.toLowerCase());
      
      if (czyDlaWszystkich || czyDlaMnie) {
        unread.push({
          id: id,
          typ: typ,
          tresc: tresc,
          autor: autor,
          dataWaznosci: Utilities.formatDate(dataWaznosci, 'Europe/Warsaw', 'dd.MM.yyyy')
        });
      }
    }
    
    return { success: true, announcements: unread };
    
  } catch (error) {
    return { success: false, message: error.toString(), announcements: [] };
  }
}

/**
 * Oznacza og≈Çoszenie jako przeczytane
 */
function markAnnouncementAsRead(idOgloszenia, loginPracownika) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Ogloszenia_odczyty');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Ogloszenia_odczyty' };
    }
    
    const now = new Date();
    const dataOdczytu = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    const godzinaOdczytu = Utilities.formatDate(now, 'Europe/Warsaw', 'HH:mm:ss');
    
    sheet.appendRow([idOgloszenia, loginPracownika, dataOdczytu, godzinaOdczytu]);
    
    return { success: true };
    
  } catch (error) {
    return { success: false, message: error.toString() };
  }
}

/**
 * Pobiera wszystkie og≈Çoszenia (dla panelu kierownika)
 */
function getAllAnnouncements() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ogloszeniaSheet = ss.getSheetByName('Ogloszenia');
    const odczytySheet = ss.getSheetByName('Ogloszenia_odczyty');
    
    if (!ogloszeniaSheet) {
      return { success: false, message: 'Nie znaleziono arkusza Ogloszenia' };
    }
    
    const data = ogloszeniaSheet.getDataRange().getValues();
    const announcements = [];
    
    // Pobierz statystyki odczyt√≥w
    const odczytyData = odczytySheet ? odczytySheet.getDataRange().getValues() : [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const id = row[0].toString();
      
      // Policz odczyty dla tego og≈Çoszenia
      let readCount = 0;
      for (let j = 1; j < odczytyData.length; j++) {
        if (odczytyData[j][0].toString() === id) {
          readCount++;
        }
      }
      
      announcements.push({
        id: id,
        dataDodania: row[1] ? Utilities.formatDate(new Date(row[1]), 'Europe/Warsaw', 'dd.MM.yyyy') : '',
        dataWaznosci: row[2] ? Utilities.formatDate(new Date(row[2]), 'Europe/Warsaw', 'dd.MM.yyyy') : '',
        typ: row[3],
        tresc: row[4],
        autor: row[5],
        odbiorcy: row[6],
        readCount: readCount
      });
    }
    
    // Sortuj od najnowszych
    announcements.reverse();
    
    return { success: true, announcements: announcements };
    
  } catch (error) {
    return { success: false, message: error.toString() };
  }
}

/**
 * Dodaje nowe og≈Çoszenie
 */
function addAnnouncement(typ, tresc, dataWaznosci, odbiorcy, autor) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Ogloszenia');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Ogloszenia' };
    }
    
    // Generuj nowe ID
    const data = sheet.getDataRange().getValues();
    let maxId = 0;
    for (let i = 1; i < data.length; i++) {
      const id = parseInt(data[i][0]) || 0;
      if (id > maxId) maxId = id;
    }
    const newId = maxId + 1;
    
    const now = new Date();
    const dataDodania = Utilities.formatDate(now, 'Europe/Warsaw', 'yyyy-MM-dd');
    
    sheet.appendRow([newId, dataDodania, dataWaznosci, typ, tresc, autor, odbiorcy]);
    
    return { success: true, id: newId };
    
  } catch (error) {
    return { success: false, message: error.toString() };
  }
}

/**
 * Usuwa og≈Çoszenie
 */
function deleteAnnouncement(idOgloszenia) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Ogloszenia');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Ogloszenia' };
    }
    
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0].toString() === idOgloszenia.toString()) {
        sheet.deleteRow(i + 1);
        return { success: true };
      }
    }
    
    return { success: false, message: 'Nie znaleziono og≈Çoszenia' };
    
  } catch (error) {
    return { success: false, message: error.toString() };
  }
}

/**
 * Pobiera listƒô pracownik√≥w (dla wyboru odbiorc√≥w)
 */
function getEmployeesList() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Pracownicy');
    
    if (!sheet) {
      return { success: false, message: 'Nie znaleziono arkusza Pracownicy' };
    }
    
    const data = sheet.getDataRange().getValues();
    const employees = [];
    
    for (let i = 1; i < data.length; i++) {
      const login = data[i][0];
      const name = data[i][2];
      
      if (login && name) {
        employees.push({
          login: login,
          name: name
        });
      }
    }
    
    employees.sort((a, b) => a.name.localeCompare(b.name, 'pl'));
    
    return { success: true, employees: employees };
    
    } catch (error) {
    return { success: false, message: error.toString() };
  }
}

  /**
 * Pobiera wszystkie nieprzeczytane og≈Çoszenia pogrupowane po pracownikach
 * Do pre-loadingu przy starcie aplikacji
 */
function getAllUnreadAnnouncementsGrouped() {
    try {
        const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
        const announcementsSheet = ss.getSheetByName('Og≈Çoszenia');
        const employeesSheet = ss.getSheetByName('Pracownicy');
        
        if (!announcementsSheet || !employeesSheet) {
            return { success: false, message: 'Brak wymaganych arkuszy' };
        }
        
        // Pobierz wszystkich pracownik√≥w
        const employeesData = employeesSheet.getDataRange().getValues();
        const employees = [];
        for (let i = 1; i < employeesData.length; i++) {
            if (employeesData[i][0]) {
                employees.push(employeesData[i][0]);
            }
        }
        
        // Pobierz wszystkie aktywne og≈Çoszenia
        const announcementsData = announcementsSheet.getDataRange().getValues();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const activeAnnouncements = [];
        for (let i = 1; i < announcementsData.length; i++) {
            const row = announcementsData[i];
            const id = row[0];
            const typ = row[1];
            const tresc = row[2];
            const dataWaznosci = new Date(row[3]);
            const odbiorcy = row[4] || 'WSZYSCY';
            const odczytanePrzez = row[6] || '';
            
            if (dataWaznosci >= today) {
                activeAnnouncements.push({
                    id: id,
                    typ: typ,
                    tresc: tresc,
                    dataWaznosci: Utilities.formatDate(dataWaznosci, 'Europe/Warsaw', 'yyyy-MM-dd'),
                    odbiorcy: odbiorcy,
                    odczytanePrzez: odczytanePrzez
                });
            }
        }
        
        // Pogrupuj og≈Çoszenia po pracownikach
        const announcementsByUser = {};
        
        employees.forEach(login => {
            const userAnnouncements = activeAnnouncements.filter(ann => {
                const isRecipient = ann.odbiorcy === 'WSZYSCY' || 
                                   ann.odbiorcy.split(',').map(s => s.trim()).includes(login);
                const alreadyRead = ann.odczytanePrzez.split(',').map(s => s.trim()).includes(login);
                return isRecipient && !alreadyRead;
            });
            
            if (userAnnouncements.length > 0) {
                announcementsByUser[login] = userAnnouncements;
            }
        });
        
        return { 
            success: true, 
            announcementsByUser: announcementsByUser 
        };
        
    } catch (error) {
        console.error('B≈ÇƒÖd getAllUnreadAnnouncementsGrouped:', error);
        return { success: false, message: error.message };
    }
}

// ===== AGENCJE ‚Äî wysy≈Çka + log =====
const WF_AGENCY_LOG_SHEET = 'Zamowienia_agencja';

function wfGetOrCreateAgencyLog_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName(WF_AGENCY_LOG_SHEET);
  if (!sh){
    sh = ss.insertSheet(WF_AGENCY_LOG_SHEET);
    sh.appendRow([
      'timestamp',
      'week_monday',
      'dept',
      'agency_name',
      'action',              // NEED / RELEASE
      'days',
      'hours_total',
      'people_max',
      'weekly_orders',
      'productivity',
      'include_pending',
      'note',
      'payload_json'
    ]);
    sh.setFrozenRows(1);
  }
  return sh;
}

function wfSendAgencyRequest(req){
  sprawdzUprawnienia();

  if (!req || typeof req !== 'object') throw new Error('Brak danych.');

  const weekMonday = String(req.weekMonday || '').trim();
  const dept = String(req.dept || '').trim();
  const agencyName = String(req.agencyName || '').trim();
  const action = String(req.action || '').trim(); // NEED / RELEASE
  const days = Array.isArray(req.days) ? req.days : [];
  const hoursTotal = Number(req.hoursTotal || 0);
  const peopleMax = Number(req.peopleMax || 0);

  if (!weekMonday) throw new Error('Brak tygodnia.');
  if (!dept) throw new Error('Brak dzia≈Çu.');
  if (!agencyName) throw new Error('Wybierz agencjƒô.');
  if (action !== 'NEED' && action !== 'RELEASE') throw new Error('B≈Çƒôdny tryb.');
  if (!days.length) throw new Error('Zaznacz dni.');
  if (!(hoursTotal >= 0)) throw new Error('B≈Çƒôdne godziny.');
  if (!(peopleMax >= 0)) throw new Error('B≈Çƒôdna liczba os√≥b.');

  const agencies = wfGetActiveAgencies(); // z kroku 3
  const ag = agencies.find(a => a.name === agencyName);
  if (!ag) throw new Error('Nie znaleziono aktywnej agencji.');

  const note = String(req.note || '').trim();
  const breakdown = String(req.breakdownText || '').trim();

  const subject = `DBK ‚Äì ${action === 'NEED' ? 'ZAM√ìWIENIE' : 'REDUKCJA'} | tydz. ${weekMonday} | ${dept}`;

  const body =
`Cze≈õƒá,

${action === 'NEED' ? 'Pro≈õba o wsparcie obsady.' : 'Informacja o mo≈ºliwo≈õci redukcji obsady.'}

Tydzie≈Ñ (poniedzia≈Çek): ${weekMonday}
Dzia≈Ç: ${dept}
Agencja: ${agencyName}

Tryb: ${action === 'NEED' ? 'POTRZEBUJEMY' : 'ODDAJEMY'}
Dni: ${days.join(', ')}
Godziny (z zaznaczonych dni): ${hoursTotal.toFixed(2)} h
Liczba os√≥b (MAX z dni): ${peopleMax}


${breakdown || '‚Äî'}

Uwagi:
${note || '‚Äî'}

Pozdrawiam`;

  const options = {};
  if (ag.cc) options.cc = ag.cc;

  GmailApp.sendEmail(ag.email, subject, body, options);

  // log do arkusza
  const sh = wfGetOrCreateAgencyLog_();
  sh.appendRow([
    new Date(),
    weekMonday,
    dept,
    agencyName,
    action,
    days.join(','),
    hoursTotal,
    peopleMax,
    Number(req.weeklyOrders || 0),
    Number(req.productivity || 0),
    req.includePending ? 'TAK' : 'NIE',
    note,
    JSON.stringify(req)
  ]);

  return { ok: true };
}
